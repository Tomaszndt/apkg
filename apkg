#! /bin/bash

readonly _apkg_version="0.0.1"

readonly cred="\e[0;91m"
readonly cblue="\e[0;94m"
readonly cyellow="\e[0;33m"
readonly cblue_bg="\e[0;104m"
readonly cred_bg="\e[0;101m"
readonly cgreen_bg="\e[0;102m"
readonly cgreen="\e[0;92m"
readonly cwhite="\e[0;97m"
readonly cbold="\e[1m"
readonly culine="\e[4m"
readonly creset="\e[0m"

readonly _sql_create_table="CREATE TABLE 'packages' ( 'file' TEXT NOT NULL, 'name' TEXT NOT NULL, 'version' TEXT NOT NULL, 'tags' TEXT, 'cpu' TEXT NOT NULL, 'built' TEXT NOT NULL, 'packager' TEXT NOT NULL, 'url' TEXT NOT NULL );"
readonly _sql_list_table

_pwd="$(pwd)"
_filename=""
return_str=""

declare -A config=()
declare -A repositories=()
# os=""
# system="" # amiga model
# language="" # ISO code

echo "apkg $_apkg_version $(date)" > apkg.log

_ts_msg_number=0;
# $1 string, $2 prefix
function _echo() {
	local msg="$1"
	local mode="n"
	local prefix="$2"

	if [[ $msg =~ ^[!@#%](.*) ]]; then
		mode=${msg:0:1}
		msg=${BASH_REMATCH[1]}
	fi

	if [[ ${#prefix} -gt 0 ]]; then
		prefix="$prefix "
	fi

	if [[ $_verbose -eq 1 ]]; then
		# prefix="$(date +%s.%N) $(printf %03d $_ts_msg_number) $prefix"
		prefix="$(printf %02X $_ts_msg_number) $prefix"
	fi

	case $mode in
	
		"@")
			if [[ $_verbose -eq 1 ]]; then
				echo -e "$prefix$cblue$msg$creset"
			fi
		;;
		"n")
			echo -e "$prefix$msg"
		;;
		"%")
			echo -e "$prefix$cred$msg$creset"
			exit 1
		;;
		"!")
			echo -e "$prefix$cred$msg$creset"
		;;
		"#")
			echo -e "$prefix$cyellow$msg$creset"
		;;	
	esac

	# msg=${msg//\\x1b\[[0-9]+m/}
	echo -e "$msg" >> "$_pwd/apkg.log"
	_ts_msg_number=$(( _ts_msg_number + 1 ))
}

function _read_config {
	local -a lines=()
	local line
	local left
	local right
	local tmp

	_echo "@reading config file $1"

	readarray lines < "$1" || { _echo "@failed to read $1"; return 1; }

	for line in "${lines[@]}"; do
		[[ $line =~ [[:space:]]*#.* ]] && continue
		if [[ $line =~ [[:space:]]*([^=]+)[[:space:]]*=[[:space:]]*\"*([^\"\n]+)\"*[[:space:]]* ]]; then
			left="${BASH_REMATCH[1]}"
			right="$(echo ${BASH_REMATCH[2]})"
			case "$left" in
				root*)
					[[ -z ${config['root']} ]] && config['root']="$(realpath "$right")/"
				;;
				repo*)
					[[ $left =~ repo[[:space:]]+([^ ]+) ]] || {
						_echo "!bad repository name in $line"
						exit 1
					}
					tmp="${BASH_REMATCH[1]}"
					[[ -z ${repositories["$tmp"]} ]] && repositories["$tmp"]="$right"
				;;
				*)
					config["$left"]="$right"
				;;
			esac
		fi # message when ignoring lines?
	done
}

function usage() {
	local binary
	local tmp
	local str_avail="available binaries:"
	local str_missing="missing binaries:"

cat << EOF
${0##*/} mode [arguments...] (switches...)
mode         arguments           description
------------ ------------------- ----------------------------
usage                            display usage information
build        filename            build a package
build        filename            build a package and register it with local repo
install      package filename    install a package
install      name(:version)      install a package
query        query               run a query
repo-list    [path]              list repo contents
repo-rescan  [path]              recreate repository database
repo-init    [path]              create a repo
package-info filename            print package metadata

short mode q=query, i=install, b=build, m=make, pi=package-info

-v         verbose output
-root=path set root path
-repo=[name@]path set repo path

EOF

	for binary in sqlite3 7z lha zip unzip unlzx rar unadf xdftool ifftool infotool ipfs; do
		[[ $(which "$binary" 2>/dev/null ) ]] && str_avail="$str_avail $binary" || str_missing="$str_missing $binary"
	done

	echo "$str_avail"
	echo "$str_missing"

	echo -e "\ncache:\t$( du -hs ${APKG}/cache )"

	exit 0
}

declare _verbose=""
declare _mode=""
declare _scan_mode="mode"
declare -a _input_names

while [[ $# -gt 0 ]]; do
	case "$_scan_mode" in
		"mode")
			case "$1" in
				"build") _mode="build"; _scan_mode="files" ;;
				"b") _mode="build"; _scan_mode="files" ;;
				"make") _mode="make"; _scan_mode="files" ;;
				"m") _mode="make"; _scan_mode="files" ;;
				"install") _mode="install"; _scan_mode="files" ;;
				"i") _mode="install"; _scan_mode="files" ;;
				"repo-rescan") _mode="repo-rescan"; _scan_mode="switches" ;;
				"repo-list") _mode="repo-list"; _scan_mode="switches" ;;
				"repo-init") _mode="repo-list"; _scan_mode="switches" ;;
				"package-info") _mode="package-info"; _scan_mode="files" ;;
				"pi") _mode="package-info"; _scan_mode="files" ;;
				"query") _mode="query"; _scan_mode="files" ;;
				"q") _mode="query"; _scan_mode="files" ;;
				"usage") usage; exit 0; ;;
				"version") _mode="version"; _scan_mode="files" ;;
				*) _echo "%invalid mode specified: \"$1\"" ;;
			esac
			shift
		;;
		"files")
			if [[ "$1" != -* ]]; then
				_input_names+=("$1") 
				shift
			else
				_scan_mode="switches"
			fi
		;;
		"switches")
			switch=${1%%=*}
			argument=${1##*=}
			case "$switch" in
				"-v") _verbose=1 ;;
				"-repo") 
					repo="$argument"
					if [[ $argument == *@* ]]; then 
						repositories["${argument%%@*}"]="${argument#*@}"
					else
						repositories['local']="$argument"
					fi
				;;
				"-root") root="$argument" ;;
				*) _echo "%invalid switch $1" ;;
			esac
			shift
		;;
	esac
done

[[ $_scan_mode == "mode" ]] && usage

# 1 file
function base() {
	if [[ $1 =~ .*[:/]([^:/]*) ]]; then
		echo "${BASH_REMATCH[1]}"
	else
		echo "$1"
	fi
}

# 1 file
function path() {
	if [[ $1 =~ (.+[:/]).* ]]; then
		echo "${BASH_REMATCH[1]}"
	fi
}

# 1 url
# 2 filename destination file name
function _get {
	local url="$1"
	local schema="file"
	local output_file="$2"

	[[ $url =~ ([a-zA-Z]+):\/\/(.*) ]] && {
		schema="${BASH_REMATCH[1]}"
	}

	case $schema in
		"file")
			cp "$url" "$output_file" || _echo "%download failed"
		;;
		"http")
			[[ $2 ]] && output_file="$2" || output_file="${url##*/}"
			if [[ -d $output_file ]]; then
				wget -q -nc -P "$output_file" "$url" || _echo "%download failed"
			else
				wget -q -nc -O "$output_file" "$url" || _echo "%download failed"
			fi
		;;
		"https")
			[[ $2 ]] && output_file="$2" || output_file="${url##*/}"
			if [[ -d $output_file ]]; then
				wget -q -nc -P "$output_file" "$url" || _echo "%download failed"
			else
				wget -q -nc -O "$output_file" "$url" || _echo "%download failed"
			fi
		;;
	esac
}

# unpack an archive file
# $1 filename
# $2 destination path
function unpack() {
	ext="${1##*.}"	
	_echo "@unpacking $1, $ext archive into $2"

	[[ ! -d "$2" ]] && _echo "!target is not a valid path" && exit 1

	case "$ext" in
		"lha")
			# lha xw="$2" "$1" &> /dev/null
			7z x -aot "$1" -o"$2" &> /dev/null
		;;
		"run")	# assuming lha self extracting archive
			lha xw="$2" "$1" &> /dev/null
		;;
		"zip")
			unzip "$1" -d "$2" &> /dev/null
		;;
		"7z")
			7z x "$1" -o"$2" &> /dev/null
		;;
		"adf")
			unadf -d "$2" "$1" &> /dev/null
		;;
		*)
			_echo "@unsupported archive type: $ext";
			cp "$1" "$2";

		;;
	esac	
}

# return uaem formatted stat/permissions string
# 1 filename
# 2 permissions
# 3 comment
function sprotect() {
	local f="--------"
	local fname="$1"
	local perms="$2"
	local td
	local tt
	local comment="$3"

	td="$(date +%Y-%m-%d)"
	tt="$(date +%T).00"

	if [[ -n "$2" ]]; then 
		[[ $perms == *h* ]] && f="h${f:1:7}"
		[[ $perms == *s* ]] && f="${f:0:1}s${f:2:7}"
		[[ $perms == *p* ]] && f="${f:0:2}p${f:3:7}"
		[[ $perms == *a* ]] && f="${f:0:3}a${f:4:7}"
		[[ $perms == *r* ]] && f="${f:0:4}r${f:5:7}"
		[[ $perms == *w* ]] && f="${f:0:5}w${f:6:7}"
		[[ $perms == *e* ]] && f="${f:0:6}e${f:7:7}"
		[[ $perms == *d* ]] && f="${f:0:7}d"
	else
		f="----rwed"
	fi
	echo "$f $td $tt $comment"
}

# set file permissions (write to uaem file)
# 1 filename
# 2 perms
# 3 comment
function protect() {
	local perms
	perms=$(sprotect "$1" "$2" "$3")
	echo "$perms" > "$1.uaem"
}

function amistat() {
	local stat="null"
	echo "$1"
	if [ -f "$1.uaem" ]; then
		stat="$(<"$1".uaem)"
	else
		stat="$(sprotect "$1" rwed)"
	fi
	echo "$stat"
}

# 1 source
# 2 destination
function filecopy() {
	cp "$1" "$2"
	if [ -f "$1.uaem" ]; then
		cp "$1.uaem" "$2.uaem"
	fi
}

# 1 file
function filedelete() {
	rm "$1"
	if [ -f "$1.uaem" ]; then
		rm "$1.uaem"
	fi
}

# 1 directory path
# 2 permissions
function dircreate() {
	mkdir -p "$1" &> /dev/null
	if [ -d "$1" ]; then
		protect "$1" "$2"
	fi
}

function dirdelete() {
	local r
	r=$( rmdir "$1" &> /dev/null )
	if [ "$r" -eq 0 ]; then
		rm "$1.uaem"
	fi
}


# detect amiga os version
# 1 path to amiga os root directory
function detectos() {
	local os="unknown"
	local sum
	local aosroot

	aosroot="$1"

	if [ ! -f "${aosroot}/Libs/version.library" ]; then echo "$os"; return 1; fi

	sum=$(sha256sum "${aosroot}Libs/version.library")
	sum=${sum%% *}

	case $sum in
		"f8d9d1663fe5ef1f925a4ad2bad3863e69e28e2075d5c1c4c3fc1bd47de926cf")
			os="1.1" # 31.334
		;;
		"0cace16871ccf7c230e9a9286f34212b3c177a4672680ef9e0e736e47eec5916")
			os="1.2" # 33.56
		;;
		"6ea82dfc0c3854967947bc47b219013974b12d2407c43d5219123d87cdc1862a")
			os="1.2" # 33.43 A1000
		;;
		"bd08525ab9b3534e47766e297827d9d7808709b64616f122f3a1d0ee6c174ccc")
			os="1.2" # 33.56, ?
		;;
		"6b95e467c1895661f3e4e6c175b20c1946d111c90156978dee070654172d2d45")
			os="1.3" #
		;;
		"33bf7beed0f3da96de214ec3e1c07ed7cf9672ff87fac416a0e7a5146ae331a4")
			os="1.3" # ?
		;;
		"af29c17c4214aff6a0d86b83bb4052fb2ce230944066069c67be276654606c16")
			os="1.3.2" # 34.28
		;;
		"844df9bb92c2c585f012f20d774c907a08c025296eebc3d828b77b86355dbbb7")
			os="1.3.3" # 34.34
		;;
		"81f7175091a663e083ed75c7bd9f751b2f6a7a283aa61b76e16b9179666c3743")
			os="1.4" # 36.1, 1.4a15, alpha
		;;
		"cd23966ea82f5eddc3c9bc32c7d43c3e5b4039c842738e523f033d5db011b228")
			os="1.4" # beta ?
		;;
		"f2ed7a7d12e74d3fc073785385a2397760fc4d9c01aa8b361fc719f0bcbdcde3")
			os="2.0" # 36.68
		;;
		"f4c026a7c5abfb9dedf0e2ab7a647c250046a08aec7f145bbaa5dd301f457e43")
			os="2.0"
		;;
		"b01cc118734a13db69707014eec485ffabc1788ac64577abe4bc9051c72a3f0a")
			os="2.0" # 36.102
		;;
		"5345d19e1588db358874a2df92b4180ffa517ecced006a45710201c6b16495c3")
			os="2.05" # 37.71 A600HD
		;;
		"7aa6e88a38e95d7096934d8a3520b72b4a65075aadb60f2a50aadc346627dea3")
			os="2.05" # 37.71
		;;
		"6f82bbb9685f284bab05b7fce2703a55f2c3ec0c73c05aa090d7724cfa65d932")
			os="2.1" # 38.36
		;;
		"fb02919cc7af0d60fd0c71cc34804a8cdf76929d91e608ad8de6773bee05b4fb")
			os="2.1" # 38.35
		;;
		"80f42572e2d4cf56ef951c84a60f39ad530c19f95f51cc8a0a8d85911762d478")
			os="2.1" # 38.30
		;;
		"cb03ae35232cdb7a8f3f4d3c642908dee08c64aae1bc60748a548beb8d283bb6")
			os="3.0"
		;;
		"8e067779d6681b1e6763aec6a67750674a1cbc28d08f5a05349b41b04361aa7a")
			os="3.0" # 39.07, beta ?
		;;
		"b39739aab1efcda75be831b4fa2355eed2e726f427a2e55187a9dee3b44da9ee")
			os="3.1" # 40.42
		;;
		"1e7679ce0356312c41e20618db0791b11e7d304bf5880cfb770d0a45b3240069")
			os="3.1" # beta ?
		;;
		"3035aa6e34e952f8bd1e83f362dded2ed70a603ba9be9bb2cb0e68f617625467")
			os="3.1.4"
		;;
		"23501aa2cceef70ad179e4347ebb290cc3e229e65b9c0cc16b450b47244bebd3")
			os="3.2"
		;;
		"7b2f66e8bd1ea7c7e1493cb5f41a2f6ad75fdee650c3d53c167f22dbba41ea50")
			os="3.2.1"
		;;
		"6cd8b104ef75f4bef3bd938515993b1ad6a8295c29f05c7478ddbae27e1fce96")
			# 3.2.2 or 3.2.2.1
			os="3.2.2"
			sum=$(sha256sum "$1/Prefs/Env-Archive/Versions/Release")
			sum=${sum%% *}
			if [[ $sum = "c718e8b86eab55df5fd353d8090b1b2d25d83d1ed70ab89b1433a79930dd5ea1" ]]; then
				os="3.2.2.1"
			fi
		;;
		"86cd464a9b8beab7f365df3b6bf172bfe3a6db2e2e487eb60e3da015b56d603e")
			# 3.5 or 3.5.1
			os="3.5"
			sum=$(sha256sum "$1/Libs/asl.library")
			sum=${sum%% *}
			if [[ $sum = "d0b9898086728f0e6516cf652c3929602a32db58bab95df6ef37eba0363d86ba" ]]; then
				os="3.5.1"
			fi
		;;
		"f4f8d774c6a23038b517567905b92dcc877aeeae0e8cacb6683d1b4e344a248d")
			os="3.5.2"
		;;
		"d3d1cf6f1787949de55f65e6a9aeedd65ed9cdbbed5ed8639ff838a0485847ec")
			os="3.9"
		;;
		"0a0c2f112b082fabc0686009384d80d6466bbb6e08935807ed4cf3f2dd41cbe7")
			os="3.9.1" # bb 1
		;;
		"c7f280def402fffb83880d2a363ad8d986faa797deff83f1a2633473515fb947")
			os="3.9.2" # bb 2
		;;
		"1640a650cb7480344b301fbbbe14ee7d7d1bfd385d23af3ef689ec841bcf6267")
			os="3.9.4" # bb 3&4
		;;
	esac 

	echo "$os"
}

# to use within build scripts
# copy single file
# 1 source
# 2 destination relative to $pkgdir
# 3 permissions
function copy() {
	local perm
	local sbase
	local spath
	local dpath
	local dbase
	local tmp="$2"
	local subdir=""
	local p=""

	tmp=$(realpath "$1")  || _echo "%invalid file/path: $1"
	tmp="${tmp/$srcdir/}"
	sbase=$(base "$tmp")
	spath=$(path "$tmp")

	dbase=$(base "$2")
	dpath=$(path "$2")

	if [[ ! $dbase ]]; then dbase="$sbase"; fi
	perm="rwed"
	if [ -n "$3" ]; then
		perm="$3"
	fi
	perm=$(sprotect "$dbase" "$perm" "${pkgname}")

	tmp="$(make_dir "${dpath}")"

	cp -f "${srcdir}${spath}${sbase}" "${tmp}/${dbase}" &&
	echo "$perm" > "${tmp}/${dbase}.uaem" #|| exit 1

}

function makedir {
	make_dir "$1" > /dev/null
}

# to use within build scripts
# create a directory
# 1 path relative to $pkgdir
# 2 icon [wb31] TODO
# > return_str contains amiga valid path
declare -A _makedir_cache
function make_dir {
	local perm
	local s="$pkgdir"
	local path="$1"
	local save

	[[ "$path" == $pkgdir* ]] && path="${1#$pkgdir/}"

	[[ "${path:0:1}" == "/" ]] && path="${path:1}"
	[[ "${path:0-1}" == "/" ]] && path="${path:0:${#path}-1}"

	if [[ -d "$pkgdir$path" ]]; then 
		return_str="$pkgdir$path"; 
		echo "$return_str"; 
		return 
	fi
	if [[ ${_makedir_cache["$path"]} ]]; then
		return_str="${_makedir_cache["$path"]}"; 
		echo "$return_str"; 
		return; 
	fi

	s="$(path_resolve_amiga "$path")"
	s="$(path_existing_amiga "$s" "${config['root']}" )/"

	[[ ${s:0:1} == '/' ]] && s="${s:1}"
	[[ ${s:0-1} == '/' ]] && s="${s:0:0-1}"
	s="${pkgdir}${s}"

	mkdir -p "${s}"

	_makedir_cache["$path"]="$s"
	return_str="$s"
	echo "$s"
}

# patch aos startup like files
#  adds tagged blocks around inserted text
# 1 filename
# 2 mode (all, end)
# 3 needle (insert after line matching this)
# 4 tag (tag block with this)
# 5 text (text to be inserted)
function userpatch() {
	local file
	local filename
	local mode="$2"
	local needle="$3"
	local tag="$4"
	local text="$5"
	local patched="0"
	local out=""
	local p
	local b
	local tmp

	p=$(path "$1")
	b=$(base "$1")
	filename=$(find "$p" -iname "$b")
	if [[ ! $filename ]]; then
		filename="${p}${b}"
		touch "$filename"
	fi
	filename=$(realpath "$1")

	file=$(< "$filename")

	if [[ $mode == *end* ]]; then
		out=$(< "$filename")$'\n'$'\n'";BEGIN ${tag}"$'\n'"$text"$'\n'";END ${tag}"$'\n'
	else
		IFS=$'\n'
		for line in $file; do
			if [[ $line =~ $needle ]]; then
				tmp=$'\n'";BEGIN ${tag}"$'\n'"$text"$'\n'";END ${tag}"$'\n'
				if [[ $mode == *before* ]]; then
					[[ $patched -eq 0 ]] && {
						out+="$tmp"
						[[ $mode != *all* ]] && patched=1
					}
					out+="$line"$'\n'
				else
					out+="$line"$'\n'
					[[ $patched -eq 0 ]] && {
						out+="$tmp"
						[[ $mode != *all* ]] && patched=1
					}
				fi
			else
				out+="$line"$'\n'
			fi
		done
	fi # mode==end
	unset IFS

	cp "$filename" "${config['root']}apkg/backup/${backup}/${filename##*/}"
	echo "filecopy \"${config['root']}apkg/backup/${backup}/${filename##*/}\" \"$1\"" >> "${config['root']}apkg/$backup.rollback"
	echo "$out" > "$filename"
}

# 1 path to file
function file_type {
	local file_output
	local r="none"
	local tmp
	local size

	file_output_full="$(file "$1")"
	file_output="${file_output_full#* }"

	case "$file_output" in
		LHa) r="archive.lha" ;;
		LZX) r="archive.lzx" ;;
		Zip) r="archive.zip" ;;
		RAR) r="archive.rar" ;;
		7-zip) r="archive.7z" ;;
		"AmigaDOS script") r="script" ;;
		"AmigaGuide file") r="guide" ;;
		"AmigaOS bitmap font") r="font.bitmap" ;;
		"AmigaOS loadseg()ble executable/binary") 
			r="executable"
			[[ $1 == *.library ]] && r="library"
			[[ $1 == *.device ]] && r="device"
			[[ $1 == *.datatype ]] && r="datatype"
		;;
		"AmigaOS object/library data") r="o" ;;
		"AmigaOS outline font") r="font.outline" ;;
		"AmigaOS outline tag") r="font.tag" ;;
		"AmigaOS shared library") r="lib" ;;
		"Amiga Workbench disk icon") r="info.disk" ;;
		"Amiga Workbench drawer icon") r="info.drawer" ;;
		"Amiga Workbench garbage icon") r="info.garbage" ;;
		"Amiga Workbench project icon") r="info.project" ;;
		"Amiga Workbench tool icon") r="info.tool" ;;
		PNG*) 
			r="image.png"
			tmp="$(grep -obaUP "\x69\x63\x4f\x6e" "$1" )" # icOn
			tmp="${tmp%:*}"
			[[ "$tmp" ]] && {
				r="info"
				size="$(stat -c %s "$1")"
				tmp="$( dd if="$1" bs=1 skip=$(( tmp + 4 )) count=$(( size - tmp - 20 )) status=none | od -An -t x1 )"
				tmp="${tmp// /}"
				if [[ $tmp =~ 8000100f(........) ]]; then
					case "${BASH_REMATCH[0]}" in
						"8000100f00000001") r+=".disk" ;;
						"8000100f00000002") r+=".drawer" ;;
						"8000100f00000003") r+=".tool" ;;
						"8000100f00000004") r+=".project" ;;
						"8000100f00000005") r+=".garbage" ;;
					esac
				fi
			}
		;;
		*)
			case $file_output_full in
				*tar*) r="archive.tar" ;;
			esac
		;;
	esac
	echo "$r"
}

# 1 name assign name
# 2 path assign value to add
function add_assign {
	local name="$1"
	local path="$2"

	[[ ${name:0-1} != ':' ]] && name="${name}:"
	[[ $path != *:* ]] && path="SYS:${path}"
	[[ $path == */ ]] && path="${path:0:0-1}"

	if [[ ${assigns["$name"]} ]]; then
		assigns["${name^^}"]+=" $path"
	else
		assigns["${name^^}"]="$path"
	fi
}

# 1 path to startup file relative to ${config['root']}
function read_assigns {
	local text
	local lines
	local line
	local -a array=()
	local name
	local tmp

	readarray -t lines < "${config['root']}$1" || return 1
	for line in "${lines[@]}"; do
		[[ $line == *\;* ]] && continue
		[[ ${line^^} =~ [^\ ]*ASSIGN.* ]] || continue
		[[ ${line^^} == *EXISTS* ]] && continue	

		array=()
		tmp="$line"
		while [[ $tmp =~ ([[:graph:]]+) ]]; do
			token="${BASH_REMATCH[1]}"
			[[ ${token^^} != ADD && ${token^^} != DEFER ]] && {
				array+=("$token")
			}
			tmp="${tmp/$token}"
		done

		[[ ${array[0]^^} != ASSIGN ]] && continue

		name="${array[1]}"

		for i in "${array[@]:2}"; do
			add_assign "$name" "$i"
		done

	done

}

# 1 amiga path
# r full path
declare -A _cache_path_resolve_amiga
function path_resolve_amiga {
	local path="$1"
	local save_sys

	if [[ $path =~ [^:]+\:.* ]]; then
		:
	else
		path="SYS:$path"
	fi

	save_sys="${assigns['SYS:']}"; assigns['SYS:']=""
	while [[ $path =~ ([^:]*:)(.*) ]]; do
		assign="${BASH_REMATCH[1]^^}"
		value="${assigns[$assign]}"
		value=${value%% *}
		path="${value}/${BASH_REMATCH[2]}"
	done
	assigns['SYS:']="$save_sys"

	return_str="$path"
	echo "$return_str"
}

# 1 path full amiga directory path
# 2 path reference path directory names are matched against
function path_existing_amiga {
	local path="$1"
	local path_reference="$2"
	local -a component_array
	local component
	local existing_component
	local p

	[[ ${path:0-1} != '/' ]] && path="$path/"

	[[ ${path_reference:0-1} == '/' ]] && path_reference="${path_reference:0:0-1}"

	p="${path}"
	while [[ ${#p} -gt 0 ]]; do
		component="${p%%/*}"
		component_array+=("${component}")
		p="${p#*/}"
	done

	p=""
	for component in "${component_array[@]}"; do
		[[ ${#component} -gt 0 ]] && {
			existing_component="$(find "$path_reference$p" -maxdepth 1 -type d -iname "$component" 2>/dev/null)"
			existing_component="${existing_component##*/}"
			if [[ $existing_component ]]; then 
				p="${p}/${existing_component}"; 
			else 
				p="${p}/${component}"; 
			fi
		}
	done

	p="${p/$path_reference}"

	return_str="$p"
	echo "$p"
} 

#############################
# main fuctionality

# 1 package file
function package_info() {
	local pkgname
	local basename
	local fullname
	
	local name
	local version
	local description
	local upstream
	local cpu
	local require
	local packager
	
	basename=$(base "$1")
	pkgname=${basename%%:*}
	fullname=$(realpath "$1")

	7z e -so "$fullname" "$pkgname.apkg" > "${config['APKG']}tmp/$pkgname.apkg"

	_echo "information for $1"

	source "${config['APKG']}tmp/$pkgname.apkg"

	_echo "       name $name"
	_echo "    version $version"
	_echo "description $description"
	_echo "        url $upstream"
	_echo "        cpu $cpu"
	_echo "   requires $require"
	_echo "  packgager $packager"
}

# return package file metadata
# 1 package file
_package_meta_last=""
_package_meta_cache=""
function package_meta() {
	local meta="null"
	if [[ $_package_meta_last != $1 ]]; then
		meta="$(7z e -so "$1" apkg-metadata 2> /dev/null)"
		_package_meta_last="$1"
		_package_meta_cache="$meta"
		echo "$meta"
	else
		echo "$_package_meta_cache"
	fi
}

## extract value by key
# 1 meta
# 2 field
function meta_get() {
	local r
	local field
	local haystack="$1"
	local needle="$2"

	IFS=$'\n'	

	for field in $haystack; do
		if [[ $field =~ ${needle}[[:space:]]+(.*) ]]; then
			r="${BASH_REMATCH[1]}"
		fi
	done
	echo "$r"
	unset IFS
}

# 1 query    repo@name([=<>!]version)(,field)
# n options  string (quiet)
# return     "0" for none 
function _repo_query {
	local args=("$@"); local options=""; 
	[[ ${#args} -gt 1 && ${args[-1]} == options* ]] && { options="${args[-1]}"; unset args[-1]; }
	local query="$1"
	local repo="local"
	local package=""
	local version="0"
	local operator=">"
	local field="version"
	local tmp=""

	if [[ $query =~ ([^@]+)@([^=<>!,]+) ]]; then
		repo="${BASH_REMATCH[1]}"
		package="${BASH_REMATCH[2]}"
	else
		repo="local"
		package="${BASH_REMATCH[1]}"
	fi

	if [[ $query =~ ([^@=<>!]+)([=<>!]+)([^,]+) ]]; then
		package="${BASH_REMATCH[1]}"
		operator="${BASH_REMATCH[2]}"
		version="${BASH_REMATCH[3]}"
		case "$operator" in
			">") : ;;
			"<") : ;;
			"=>") : ;;
			"=<") : ;;
			"=") : ;;
			"==") : ;;
			"!=") : ;;
			*) _echo "%invalid operator, $operator in $query" ;;
		esac
	fi

	[[ $query =~ ([=<>!])?([^,]+),([^,]+) ]] && {
		field="${BASH_REMATCH[3]}"
	}

	_repo_get_db "$repo"

	tmp="$(sqlite3 "${APKG}cache/$repo-repo.db" "select $field from packages where name = '$package' and version $operator '$version' order by $field desc limit 1")"

	[[ -z "$tmp" ]] && tmp="0"

	return_str="$tmp"
	[[ "${options}" != *quiet* ]] && echo "$tmp"

}

# 1 name repo name
function _repo_get_db {
	local repo="$1"
	local url="${repositories["$repo"]}"

	[[ $url == */ ]] && url="${url:1:0-1}"

	[[ -f "${APKG}cache/$repo-repo.db" ]] || {

		_get "${url}/repo.db" "${APKG}cache/$repo-repo.db"

	}
}

# 1 query (repo@name([=<>!]version)
# n options  string (quiet)
function _repo_get_pkgfile {
	local args=("$@"); local options=""; 
	[[ ${#args} -gt 1 && ${args[-1]} == options* ]] && { options="${args[-1]}"; unset args[-1]; }

	local query="$1"
	local repo="local"
	local package=""

	if [[ $query =~ ([^@]+)@([^=<>!,]+) ]]; then
		repo="${BASH_REMATCH[1]}"
		package="${BASH_REMATCH[2]}"
	else
		_echo "%_repo_get_pkgfile: requires both repo name and package name ($query)"
	fi

	_repo_get_db "$repo"

	return_str="$(_repo_query "${repo}@${package},file")"

	_get "${repositories["$repo"]}/${return_str}" "${APKG}cache/${return_str}"

	[[ "${options}" != *quiet* ]] && echo "${APKG}cache/${return_str}"
}

# is specific package version present in the repo
# 1 query    repo@name([=<>!]version)
# n options  string (quiet)
# return     "0" for none 
function _repo_has() {
	local args=("$@")

	local query="$1"

	tmp="$(_repo_query "${query},version")"

	[[ -z "$tmp" ]] && tmp="0"

	return_str="$tmp"
	[[ "${args[-1]}" != *quiet* ]] && echo "$tmp"
}

# init local repository
# 1 repo path
function _repo_init() {
	local path="$1"

	[[ $path != */ ]] && path="${path}/"

	mkdir -p "$path" &> /dev/null
	rm "${path}repo.db" &> /dev/null
	sqlite3 "${path}repo.db" "$_sql_create_table"

	if [ $? -eq 0 ]; then
		_echo "@created repository in $1"
	else
		_echo "!failed to initialise repository $1"
		return 1
	fi
}

# add package to local repository
# 1 package file
# 2 repository path
function repo_add_package() {
	local meta
	local file
	local name 
	local version
	local cpu
	local built
	local packager
	local url
	local query
	local repopath
	local tmp

	[[ "$2" ]] && repopath="$2" || repopath="${repositories['local']}"
	file="${1}"

	[[ $repopath == */ ]] || repopath="${repopath}/"

	[[ ! -f "${repopath}repo.db" ]] && _repo_init "${repopath}"
	# [[ "$(sqlite3 "${repopath}repo.db" 'select sqlite_version()')" < "3" ]] && _repo_init "$repopath"

	meta=$(package_meta "$file")

	name=$(meta_get "$meta" "name")
	version=$(meta_get "$meta" "version")
	cpu=$(meta_get "$meta" "cpu")
	built=$(meta_get "$meta" "built")
	packager=$(meta_get "$meta" "packager")
	url=$(meta_get "$meta" "url")
	tags=$(meta_get "$meta" "tags")

	query="insert into packages ('file', 'name', 'version', 'cpu', 'tags', 'built', 'packager', 'url') values ('${file##*/}', '$name', '$version', '$cpu', '$tags', '$built', '$packager', '$url' ) "
	tmp=$(sqlite3 "${repopath}repo.db" "select name from packages where name='$name' and version ='$version'")
	if [[ "$tmp" < "0" ]]; then
		sqlite3 "${repopath}repo.db" "$query"
		_echo "@added $name, $version into $repopath"
	else
		_echo "@$name, $version already present in $repopath"
	fi
}

# populate repository database
# 1 repo path
function repo_populate() {
	local i

	_repo_init "$1"

	for i in "$1"/*.7z; do
		repo_add_package "$i" "$1"
	done
}


# make sure database file is up to date
# 1 repo path
function repo_update() {
	local f
	local path="$1"

	[[ $path == */ ]] || path="${path}/"

	f=$(ls -t "${path}")

	if [[ $f =~ ^repo.db ]]; then
		_echo "@database file up to date"
	else
		rm "${path}repo.db" 2&> /dev/null
		_echo "@removed database file in ${path}"
		repo_populate "${path}"
	fi
	
}

#
# 1 repo repo name
function repo_list() {
	local repo="$1"

	_repo_get_db "$repo"

	_echo "package listing for ${repo}@${repositories[$repo]}"

	sqlite3 "${APKG}cache/$repo-repo.db" << SQL 
.mode columns 
select name, version, cpu, built, tags from packages order by name asc
SQL

	_echo "@end of listing"
}

#
# make a "binary" package
# $1 package script name
_pkgfile=""
function _pkg_build() {
	local _script_file
	local _downloaded_file
	local _basename_file
	local _file_checksum
	local dlpaths
	typeset -A sums=()
	local shasum
	local items=0
	
	# is the script file available 
	_script_file="$1"
	[[ -z $_script_file ]] && _echo "%build script not found \"$_filename\"";
	_script_file=$(realpath "$_script_file")

	source "$_script_file"
	
	_echo "#building $name, version $version, $packager"

	# download files
	for s in "${source[@]}"; do
		items=$items+1

		IFS='*' read -r -a array <<< "$s";

		case ${#array[*]} in
			2)
				_source_file="${array[0]}"
				_file_checksum="${array[1]}"
				_basename_file="${_source_file##*/}"
				sums+=(["$_basename_file"]="$_file_checksum")
			;;
			3)
				_source_file="${array[0]}"
				_file_checksum="${array[1]}"
				_basename_file="${array[2]}"
				sums+=(["$_basename_file"]="$_file_checksum")
			;;
			*)
				_echo "!malformed source line $s"
				exit 1
			;;
		esac
		unset IFS
		
		_downloaded_file="null"
		if [[ -f "./$_basename_file" ]]; then
			_downloaded_file="./$_basename_file"
		fi
		if [[ -f "${config['APKG']}downloads/$_basename_file" ]]; then
			_downloaded_file="./$_basename_file"
		fi

		if [[ "$_downloaded_file" == "null" ]]; then			
			_echo "downloading $_source_file"
			wget -q --show-progress -nc -P "${config['APKG']}downloads" -O "$_basename_file" "$_source_file" #&> /dev/null
			cp "$_basename_file" "${config['APKG']}downloads" &> /dev/null
		else
			_echo "$_basename_file found in download cache"
			cp "$_downloaded_file" "${config['APKG']}downloads" &> /dev/null
		fi
			
	done
	
	# verify checksums
	for f in "${!sums[@]}"; do
		shasum=$(sha256sum "${config['APKG']}downloads/$f")
		shasum=${shasum%% *}
		if [[ $shasum != "${sums[$f]}" ]]; then
			_echo "!$f : invalid checksum: $shasum"; 
			exit 1
		else
			_echo "@$f chcecksum ok"
		fi
		
	done

	local pkgname="$name~$version~$cpu"
	
	rm -r "${config['APKG']}tmp/" &> /dev/null 
	mkdir -p "${config['APKG']}tmp"

	for _file in "${!sums[@]}"; do
		unpack "${config['APKG']}downloads/$_file" "${config['APKG']}tmp"
	done

	rm -r "${config['APKG']}cache/$pkgname/" &> /dev/null 
	mkdir -p "${config['APKG']}cache/$pkgname"

	pkgdir="${config['APKG']}cache/$pkgname/"
	srcdir="${config['APKG']}tmp/"
	local _cwd="$(pwd)"

	_echo "@running build script"
	cd "$srcdir" || _echo "%invalid source directory ($srcdir)"
	root="${config['root']}"
	build || _echo "%build script failed"
	unset IFS
	
	cd "$pkgdir" || _echo "%invalid $pkgdir";

	_echo "generating install script"

	IFS=$'\n'
	files=$(find "$pkgdir" ! -iname "*.apkg" ! -iname apkg-metadata | sort)

	echo "# $name $version" > apkg-install
	echo "## apkg $_apkg_version" >> apkg-install
	for file in $files; do
		if [ -d "$file" ]; then
			f=${file/$pkgdir/}
			if [ ${#f} -gt 0 ]; then
				echo "dircreate $f" >> apkg-install
			fi
		fi
	done
	for file in $files; do
		if [ -f "$file" ]; then
			f=${file/$pkgdir/}
			echo "filecopy $f $f" >> apkg-install
		fi
	done
	unset IFS

	# metadata file
	_echo "generating metadata"
	cd "$pkgdir" || exit 1
	touch apkg-metadata
	echo -e "name $name\nversion $version\ncpu $cpu\ntags $tags\nbuilt $(date +%s)\npackager $packager\nurl $upstream\nbuildscript ${_script_file##*/}" > apkg-metadata

	cp "$_script_file" "."

	# archive all the files
	_echo "compressing the package"
	7z a -mx=9 "$pkgname.7z" ./* &> /dev/null
	
	cd "$_cwd" || exit 1

	_pkgfile="$pkgname.7z"
	mv "${pkgdir}${pkgname}.7z" "."
	# mv "${pkgdir}${pkgname}.7z" "${repositories['local']}/"
	# repo_add_package "${pkgname}.7z"
	
	return_str="$_pkgfile"
}

# initializes apkg databases in ${config['root']}
function _install_init_root {
	if [ ! -d "${config['root']}/apkg/" ]; then
		mkdir -p "${config['root']}/apkg"
		protect "${config['root']}/apkg" "rwed" "apkg:$_apkg_version"
		_echo "@created apkg directory in ${config['root']}"
	fi
	if [ ! -f "${config['root']}/apkg/apkg.db" ]; then
		sqlite3 "${config['root']}/apkg/apkg.db" "CREATE TABLE 'packages' ( 'file' TEXT NOT NULL, 'name' TEXT NOT NULL, 'version' TEXT NOT NULL, 'cpu' TEXT NOT NULL, 'built' TEXT NOT NULL, 'packager' TEXT NOT NULL, 'url' TEXT NOT NULL);"
		protect "${config['root']}/apkg/apkg.db" "rwed" "apkg:$_apkg_version"
		_echo "@created apkg database file in ${config['root']}"
	fi
}

# 1 package filename
function package_is_installed() {
	local meta
	local pkgname
	local count

	meta=$(package_meta "$1")
	pkgname=$(meta_get "$meta" "name")

	count=$(sqlite3 "${config['root']}/apkg/installed.db" "select version from packages where name='$pkgname' order by version desc")

	echo "$count"
}

# return version number for package if installed, otherwise return 0
# 1 package name
function is_installed() {
	local pkgname
	local version

	pkgname="$1"

	version=$(sqlite3 "${config['root']}apkg/installed.db" "select version from packages where name='$pkgname' order by version desc limit 1")

	if [ $version ]; then
		echo "$version"
	else
		echo "0"
	fi
}

# 1 package file name
function install_register_package() {
	local meta
	local pkgfilename
	local pkgname
	local pkgversion
	local pkgcpu


	meta=$(package_meta "$1")
	pkgfilename="$1"
	pkgname=$(meta_get "$meta" "name")
	pkgversion=$(meta_get "$meta" "version")
	pkgcpu=$(meta_get "$meta" "cpu")

	if [ ! -f "${config['root']}apkg/installed.db" ]; then
		sqlite3 "${config['root']}apkg/installed.db" "create table 'packages' ('file' TEXT NOT NULL, 'name' TEXT NOT NULL, 'version' TEXT NOT NULL, 'cpu' TEXT NOT NULL)" 
	fi

	sqlite3 "${config['root']}apkg/installed.db" "insert or ignore into 'packages' ('file', 'name', 'version', 'cpu') values ('$pkgfilename', '$pkgname', '$pkgversion', '$pkgcpu')"
	_echo "@registered package $pkgname version $pkgversion"
}

#
# 1 source
# 2 destination
# 3 backup path
function install_file() {
	local source="$1"
	local destination="$2"
	local backup="$3"
	
	local psource=$(path "$source")
	local bsource=$(base "$source")
	local pdestination=$(path "$destination")
	local bdestination=$(base "$destination")

	if [[ -f "$destination" ]]; then
		_echo "@$destination backed up in $backup"
		cp "$destination" "$backup"
		rm "$destination"
		cp "$source" "$destination"
	else
		cp "$source" "$destination"
	fi

	if [[ -f "$source.uaem" ]]; then
		cp "$source.uaem" "$destination.uaem"
	fi

}

# 1 require list
# return 0 if all met, 1 otherwise
function package_check_deps() {
	local req
	local pkgname
	local pkgversion
	local relation
	local iversion
	local ret=0

	req="$1"

	req=${req//\ /}
	if [[ $1 = "" ]]; then _echo "@no dependencies"; return 0; fi

	_echo "@package dependency list = '${req//,/, }'"

	IFS=,
	for r in $req; do
		relation="any"

		if [[ $r =~ ([^<>=]+)([<>=]+)([^<>=]+) ]]; then
			pkgname="${BASH_REMATCH[1]}"
			pkgversion="${BASH_REMATCH[3]}"
			relation="${BASH_REMATCH[2]}"
		else
			pkgname="$r"
			pkgversion=0
			relation="any"
		fi

		iversion=$(is_installed "$pkgname")

		if [[ $iversion > "0" ]]; then
			case $relation in
				"any")
					_echo "@$pkgname required, $iversion installed"
				;;
				">")
					if [[ $iversion > $pkgversion ]]; then
						_echo "@$pkgname > $pkgversion required, $iversion installed"
					fi
				;;
				"<")
					if [[ $iversion < $pkgversion ]]; then
						_echo "@$pkgname > $pkgversion required, $iversion installed"
					fi
				;;				
				"=")
					if [[ $iversion == $pkgversion ]]; then
						_echo "@$pkgname > $pkgversion required, $iversion installed"
					fi
				;;
			esac
		else
			_echo "!$pkgname version $pkgversion required, none installed"
			return 1
		fi
	
	done
	unset IFS

	return $ret
}

#
# install the package
# 1 package file
function install_package() {
	local filename
	local files
	local fbase
	local osversion
	local tmpdir=""
	local tmpdir_length=0
	local meta
	local backup
	local pkgname
	local pkgversion
	root="${config['root']}" # needed within build scripts

	_install_init_root

	filename=$(realpath "$1")

	if [ ! -f "$filename" ]; then
		_echo "!file not found $filename";
		exit 1
	fi

	# osversion=$(detectos "${config['root']}")

	meta=$(package_meta "$filename")
	pkgname=$(meta_get "$meta" "name")
	pkgversion=$(meta_get "$meta" "version")
	backup="$pkgname-$pkgversion"

	[[ -f "${config['root']}/apkg/$backup.rollback" ]] && _echo "%$filename already installed"

	_echo "#installing $_filename"

	# _echo "detected Amiga OS version $osversion" # not used here at the moment
	
	tmpdir="${config['APKG']}tmp/"
	rm -r "$tmpdir" #&> /dev/null
	mkdir -p "$tmpdir"
	tmpdir_length=${#tmpdir}

	unpack "$1" "${config['APKG']}tmp"

	tmp2=$(meta_get "$meta" "buildscript")

	source "${config['APKG']}tmp/$tmp2"

	package_check_deps "$require"

	if [[ $? -gt 0 ]]; then _echo "!dependencies not met"; exit 1; fi

	_echo "installing files"
	mkdir -p "${config['root']}/apkg/backup/$backup"
	true > "${config['root']}/apkg/$pkgname-$pkgversion.rollback"

	IFS=$'\n'
	files=$(find "${config['APKG']}tmp" ! -iname "*.uaem" ! -iname "apkg-*" ! -iname "*.apkg")
	for f in $files; do
		fbase=$(base "$f")
		if [[ "$f/" == "$tmpdir" ]]; then continue; fi
		if [ -d "$f" ]; then
			[[ ! -d "${config['root']}/${f:$tmpdir_length}" ]] && {
				mkdir -p "${config['root']}/${f:$tmpdir_length}"
				protect "${config['root']}/${f:$tmpdir_length}"
				echo -e "dirdelete ${f:$tmpdir_length}" >> "${config['root']}/apkg/$pkgname-$pkgversion.rollback"
			}
		fi
		if [ -f "$f" ]; then
			if [ -f "${config['root']}/${f:$tmpdir_length}" ]; then
				# conflicting file
				install_file "$f" "${config['root']}${f:$tmpdir_length}" "${config['root']}apkg/backup/$backup"

				echo "filedelete ${f:$tmpdir_length}" >> "${config['root']}apkg/$pkgname-$pkgversion.rollback"
				echo "filecopy ${config['root']}apkg/backup/$backup/$fbase ${config['root']}${f:$tmpdir_length}" >> "${config['root']}apkg/$pkgname-$pkgversion.rollback"
			else
				install_file "$f" "${config['root']}${f:$tmpdir_length}" "${config['root']}apkg/backup/$backup"

				echo "filedelete ${f:$tmpdir_length}" >> "${config['root']}apkg/$pkgname-$pkgversion.rollback"
			fi
		fi

	done
	unset IFS

	if [[ $(type -t post_install) == "function" ]]; then
		_echo "running install script"
		post_install || exit 1
	else
		_echo "@no post_install script"
	fi

	sort -r "${config['root']}/apkg/$pkgname-$pkgversion.rollback" > "${config['root']}/apkg/$pkgname-$pkgversion.rollback.tmp"
	rm "${config['root']}/apkg/$pkgname-$pkgversion.rollback"
	mv "${config['root']}/apkg/$pkgname-$pkgversion.rollback.tmp" "${config['root']}/apkg/$pkgname-$pkgversion.rollback"

	install_register_package "$1"

	_echo "installation complete"
}

# install single package from a repository
# 1 package package query ( repo@name([=<>!]version) )
function install_repo() {
	local query="$1"
	local pkgname
	local pkgversion
	local pkgfile

	pkgfile="$(_repo_get_pkgfile "$query")"


	[[ "$pkgfile" ]] || _echo "%package ${1} not found in ${repo}"
	
	install_package "${pkgfile}"
}

#############################

[[ -z "$APKG" ]] && APKG="$HOME/.apkg"
[[ "$APKG" != */ ]] && APKG="$APKG/"
[[ ! -d "$APKG" ]] && {
	_echo "@creating working directory, path: '$APKG'"
	mkdir -p "$APKG"
	}
[[ ! -d "${APKG}repo" ]] && mkdir "${APKG}repo"
[[ ! -d "${APKG}tmp" ]] && mkdir "${APKG}tmp"
[[ ! -d "${APKG}downloads" ]] && mkdir "${APKG}downloads"
[[ ! -d "${APKG}cache" ]] && mkdir "${APKG}cache"
[[ ! -d "${APKG}RAM" ]] && { 
	mkdir "${APKG}RAM"; 
	mkdir "${APKG}RAM/T"; 
	mkdir "${APKG}RAM/CLIPBOARDS"; 
	mkdir "${APKG}RAM/ENV"
	}

rm -rd "${APKG}cache/"* &> /dev/null

declare -A assigns

_read_config "$HOME/.apkg/apkg.config" 
_read_config "./apkg.config"

for key in "${!config[@]}"; do _echo "@$key = ${config[$key]}"; done
for key in "${!repositories[@]}"; do _echo "@repo $key = ${repositories[$key]}"; done

[[ ! -d "${config['root']}" ]] && _echo "%invalid target root path: ${config['root']}"
[[ ! -d "${repositories['local']}" ]] && _echo "%invalid local repo path: '${repositories['local']}'"

if [[ -z ${config['cpu']} ]]; then config['cpu']="68020"; fi

config['APKG']="$APKG"

assigns['SYS:']="$(realpath "${config['root']}")"
assigns['RAM:']="${APKG}RAM"
add_assign "C:" "SYS:C"
add_assign "DEVS:" "SYS:Devs"
add_assign "ENVARC:" "Prefs/Env-Archive"
add_assign "FONTS:" "SYS:Fonts"
add_assign "L:" "SYS:L"
add_assign "LIBS:" "SYS:Libs"
add_assign "S:" "SYS:S"
read_assigns "S/Startup-Sequence" &> /dev/null
read_assigns "S/User-Startup" &> /dev/null

#
# print config
for key in "${!v[@]}"; do _echo "@$key = ${v[$key]}"; done
for key in "${!assigns[@]}"; do _echo "@assign $key ${assigns[$key]}"; done

# _repo_has "local@ixemul<63"
# _repo_query "local@make>1,tags" "2nd" "options: quiet"
# _repo_get_pkgfile "warez@make" "options quiet"

########
# top level logic

case $_mode in
	"build")
		[[ ${#_input_names} -eq 0 ]] && _echo "%no input files"
		for _filename in "${_input_names[@]}"; do
			_pkg_build "$_filename"
			_echo "created package: $return_str"
		done
	;;
	"make")
		[[ ${#_input_names} -eq 0 ]] && _echo "%no input files"
		for _filename in "${_input_names[@]}"; do
			_pkg_build "$_filename"
			repo_add_package "$return_str"
			rm "$return_str"
		done
	;;	
	"query")
		[[ ${#_input_names} -eq 0 ]] && _echo "%no queries"
		for _filename in "${_input_names[@]}"; do
			tmp="$(_repo_query "$_filename" "quiet")"
			if [[ $tmp == "0" ]]; then
				echo "no result for $_filename"
			else
				echo "$tmp"
			fi
		done
	;;		
	"install")
		tmp=0
		[[ ${#_input_names} -eq 0 ]] && _echo "%no input files"
		for _filename in "${_input_names[@]}"; do
			if [[ -f $_filename && $_filename != *.apkg ]]; then
				install_package "$_filename"
				tmp=1
			fi
			if [[ $_filename == *.apkg ]]; then
				_pkg_build "$_filename"
				install_package "${repo}${_pkgfile}"
				tmp=1
			fi
			if [ $tmp -gt 0 ]; then
				: # done
			else
				[[ $_filename != *@* ]] && _filename="local@${_filename}"
				install_repo "$_filename"
			fi
		done
	;;
	"repo-init")
		_repo_init "${repositories['local']}"
		repo_populate "${repositories['local']}"
	;;
	"repo-list")
		repo_list "local"
	;;
	"repo-rescan")
		repo_populate "${repositories['local']}"
	;;
	"package-info")
		package_info "$_filename"
	;;
	"version")
		echo $_apkg_version
	;;
esac



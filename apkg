#! /bin/bash

readonly _apkg_version="0.0.1"

readonly cred="\e[0;91m"
readonly cblue="\e[0;94m"
readonly cyellow="\e[0;33m"
readonly cblue_bg="\e[0;104m"
readonly cred_bg="\e[0;101m"
readonly cgreen_bg="\e[0;102m"
readonly cgreen="\e[0;92m"
readonly cwhite="\e[0;97m"
readonly cbold="\e[1m"
readonly culine="\e[4m"
readonly creset="\e[0m"

readonly _sql_create_table="CREATE TABLE 'packages' ( 'file' TEXT NOT NULL, 'name' TEXT NOT NULL, 'version' TEXT NOT NULL, 'tags' TEXT, 'cpu' TEXT NOT NULL, 'built' TEXT NOT NULL, 'packager' TEXT NOT NULL, 'url' TEXT NOT NULL );"
readonly _sql_list_table

_pwd="$(pwd)"
_filename=""
return_str=""

declare -A config=()
declare -A repositories=()
# os=""
# system="" # amiga model
# language="" # ISO code

echo "apkg $_apkg_version $(date)" > apkg.log

_ts_msg_number=0;
# $1 string, $2 prefix
function _echo() {
	local msg="$1"
	local mode="n"
	local prefix="$2"

	if [[ $msg =~ ^[!@#%](.*) ]]; then
		mode=${msg:0:1}
		msg=${BASH_REMATCH[1]}
	fi

	if [[ ${#prefix} -gt 0 ]]; then
		prefix="$prefix "
	fi

	if [[ $_verbose -eq 1 ]]; then
		# prefix="$(date +%s.%N) $(printf %03d $_ts_msg_number) $prefix"
		prefix="$(printf %02X $_ts_msg_number) $prefix"
	fi

	case $mode in
	
		"@")
			if [[ $_verbose -eq 1 ]]; then
				echo -e "$prefix$cblue$msg$creset" >&2
			fi
		;;
		"n")
			echo -e "$prefix$msg" >&2
		;;
		"%")
			echo -e "$prefix$cred$msg$creset" >&2
			exit 1
		;;
		"!")
			echo -e "$prefix$cred$msg$creset" >&2
		;;
		"#")
			echo -e "$prefix$cyellow$msg$creset" >&2
		;;	
	esac

	# msg=${msg//\\x1b\[[0-9]+m/}
	echo -e "$msg" >> "$_pwd/apkg.log"
	_ts_msg_number=$(( _ts_msg_number + 1 ))
}

function _read_config {
	local -a lines=()
	local line
	local left
	local right
	local tmp

	_echo "@reading config file $1"

	readarray lines < "$1" || { _echo "@failed to read $1"; return 1; }

	for line in "${lines[@]}"; do
		[[ $line =~ [[:space:]]*#.* ]] && continue
		if [[ $line =~ [[:space:]]*([^=]+)[[:space:]]*=[[:space:]]*\"*([^\"\n]+)\"*[[:space:]]* ]]; then
			left="${BASH_REMATCH[1]}"
			right="$(echo ${BASH_REMATCH[2]})"
			case "$left" in
				root*)
					[[ -z ${config['root']} ]] && config['root']="$(realpath "$right")/"
				;;
				repo*)
					[[ $left =~ repo[[:space:]]+([^ ]+) ]] || {
						_echo "!bad repository name in $line"
						exit 1
					}
					tmp="${BASH_REMATCH[1]}"
					[[ -z ${repositories["$tmp"]} ]] && repositories["$tmp"]="$right"
				;;
				*)
					config["$left"]="$right"
				;;
			esac
		fi # message when ignoring lines?
	done
}

function usage() {
	local binary
	local tmp
	local str_avail="available binaries:"
	local str_missing="missing binaries:"

cat << EOF
${0##*/} mode [arguments...] (switches...)
mode         arguments           description
------------ ------------------- ----------------------------
usage                            display usage information
build        filename            build a package
make         filename            build a package and register it with local repo
install      package filename    install a package
install      name(:version)      install a package
query        query               run a query
repo-list    [path]              list repo contents
repo-rescan  [path]              recreate repository database
repo-init    [path]              create a repo
package-info filename            print package metadata

short mode q=query, i=install, b=build, m=make, pi=package-info

-v         verbose output
-root=path set root path
-repo=[name@]path set repo path

EOF

	for binary in sqlite3 7z lha zip unzip unlzx rar unadf xdftool ifftool infotool ipfs; do
		[[ $(which "$binary" 2>/dev/null ) ]] && str_avail="$str_avail $binary" || str_missing="$str_missing $binary"
	done

	echo "$str_avail"
	echo "$str_missing"

	echo -e "\ncache:\t$( du -hs ${APKG}/cache )"

	exit 0
}

declare _verbose=""
declare _mode=""
declare _scan_mode="mode"
declare -a _input_names

while [[ $# -gt 0 ]]; do
	case "$_scan_mode" in
		"mode")
			case "$1" in
				"build") _mode="build"; _scan_mode="files" ;;
				"b") _mode="build"; _scan_mode="files" ;;
				"make") _mode="make"; _scan_mode="files" ;;
				"m") _mode="make"; _scan_mode="files" ;;
				"install") _mode="install"; _scan_mode="files" ;;
				"i") _mode="install"; _scan_mode="files" ;;
				"repo-rescan") _mode="repo-rescan"; _scan_mode="switches" ;;
				"repo-list") _mode="repo-list"; _scan_mode="switches" ;;
				"repo-init") _mode="repo-list"; _scan_mode="switches" ;;
				"package-info") _mode="package-info"; _scan_mode="files" ;;
				"pi") _mode="package-info"; _scan_mode="files" ;;
				"query") _mode="query"; _scan_mode="files" ;;
				"q") _mode="query"; _scan_mode="files" ;;
				"usage") usage; exit 0; ;;
				"version") _mode="version"; _scan_mode="files" ;;
				*) _echo "%invalid mode specified: \"$1\"" ;;
			esac
			shift
		;;
		"files")
			if [[ "$1" != -* ]]; then
				_input_names+=("$1") 
				shift
			else
				_scan_mode="switches"
			fi
		;;
		"switches")
			switch=${1%%=*}
			argument=${1##*=}
			case "$switch" in
				"-v") _verbose=1 ;;
				"-repo") 
					repo="$argument"
					if [[ $argument == *@* ]]; then 
						repositories["${argument%%@*}"]="${argument#*@}"
					else
						repositories['local']="$argument"
					fi
				;;
				"-root") root="$argument" ;;
				*) _echo "%invalid switch $1" ;;
			esac
			shift
		;;
	esac
done

[[ $_scan_mode == "mode" ]] && usage

# 1 file
function base() {
	if [[ $1 =~ .*[:/]([^:/]*) ]]; then
		echo "${BASH_REMATCH[1]}"
	else
		echo "$1"
	fi
}

# 1 file
function path() {
	if [[ $1 =~ (.+[:/]).* ]]; then
		echo "${BASH_REMATCH[1]}"
	fi
}

# 1 url
# 2 filename destination file name
function _get {
	local url="$1"
	local schema="file"
	local output_file="$2"

	[[ $url =~ ([a-zA-Z]+):\/\/(.*) ]] && {
		schema="${BASH_REMATCH[1]}"
	}

	case $schema in
		"file")
			cp "$url" "$output_file" || _echo "%download failed"
		;;
		"http")
			[[ $2 ]] && output_file="$2" || output_file="${url##*/}"
			if [[ -d $output_file ]]; then
				wget -q -nc -P "$output_file" "$url" || _echo "%[$FUNCNAME] download failed"
			else
				wget -q -nc -O "$output_file" "$url" || _echo "%[$FUNCNAME] download failed"
			fi
		;;
		"https")
			[[ $2 ]] && output_file="$2" || output_file="${url##*/}"
			if [[ -d $output_file ]]; then
				wget -q -nc -P "$output_file" "$url" || _echo "%[$FUNCNAME] download failed"
			else
				wget -q -nc -O "$output_file" "$url" || _echo "%[$FUNCNAME] download failed"
			fi
		;;
	esac
}

# unpack an archive file
# $1 filename
# $2 destination path
function _unpack {
	ext="${1##*.}"	
	_echo "@[$FUNCNAME] unpacking $1, $ext archive into $2"

	[[ ! -d "$2" ]] && _echo "%[$FUNCNAME] target is not a valid path"

	case "$ext" in
		"lha")
			# lha xw="$2" "$1" &> /dev/null
			7z x -aot "$1" -o"$2" &> /dev/null
		;;
		"run")	# assuming lha self extracting archive
			lha xw="$2" "$1" &> /dev/null
		;;
		"zip")
			unzip -n "$1" -d "$2" &> /dev/null
		;;
		"7z")
			7z x "$1" -o"$2" &> /dev/null
		;;
		"adf")
			unadf -d "$2" "$1" &> /dev/null
		;;
		*)
			_echo "@[$FUNCNAME] unsupported archive type: $ext";
			cp "$1" "$2";
		;;
	esac	
}
function unpack { 
	_unpack "$1" "$2"
}

# 1 archive, archive filename
# 2 file, file to extract
function _extract {
	local archive="$1"
	local file="$2"

	case $archive in
		*.7z) 
			7z e -y -o"${APKG}tmp/" "$archive" "$file" &> /dev/null
		;;
	esac

	return_str="${APKG}tmp/$file"
	echo "$return_str"
}

# return uaem formatted stat/permissions string
# 1 filename
# 2 permissions
# 3 comment
function sprotect() {
	local f="--------"
	local fname="$1"
	local perms="$2"
	local td
	local tt
	local comment="$3"

	td="$(date +%Y-%m-%d)"
	tt="$(date +%T).00"

	if [[ -n "$2" ]]; then 
		[[ $perms == *h* ]] && f="h${f:1:7}"
		[[ $perms == *s* ]] && f="${f:0:1}s${f:2:7}"
		[[ $perms == *p* ]] && f="${f:0:2}p${f:3:7}"
		[[ $perms == *a* ]] && f="${f:0:3}a${f:4:7}"
		[[ $perms == *r* ]] && f="${f:0:4}r${f:5:7}"
		[[ $perms == *w* ]] && f="${f:0:5}w${f:6:7}"
		[[ $perms == *e* ]] && f="${f:0:6}e${f:7:7}"
		[[ $perms == *d* ]] && f="${f:0:7}d"
	else
		f="----rwed"
	fi
	echo "$f $td $tt $comment"
}

# set file permissions (write to uaem file)
# 1 filename
# 2 perms
# 3 comment
function protect() {
	local perms
	perms=$(sprotect "$1" "$2" "$3")
	echo "$perms" > "$1.uaem"
}

function amistat() {
	local stat="null"
	echo "$1"
	if [ -f "$1.uaem" ]; then
		stat="$(<"$1".uaem)"
	else
		stat="$(sprotect "$1" rwed)"
	fi
	echo "$stat"
}

# 1 source
# 2 destination
function filecopy() {
	cp "$1" "$2"
	if [ -f "$1.uaem" ]; then
		cp "$1.uaem" "$2.uaem"
	fi
}

# 1 file
function filedelete() {
	rm "$1"
	if [ -f "$1.uaem" ]; then
		rm "$1.uaem"
	fi
}

# 1 directory path
# 2 permissions
function dircreate() {
	mkdir -p "$1" &> /dev/null
	if [ -d "$1" ]; then
		protect "$1" "$2"
	fi
}

function dirdelete() {
	local r
	r=$( rmdir "$1" &> /dev/null )
	if [ "$r" -eq 0 ]; then
		rm "$1.uaem"
	fi
}

# detect amiga os version
# 1 path to amiga os root directory
function _detectos() {
	local os="unknown"
	local sum
	local aosroot

	aosroot="$1"

	if [ ! -f "${aosroot}/Libs/version.library" ]; then echo "$os"; return 1; fi

	sum=$(sha256sum "${aosroot}Libs/version.library")
	sum=${sum%% *}

	case $sum in
		"f8d9d1663fe5ef1f925a4ad2bad3863e69e28e2075d5c1c4c3fc1bd47de926cf")
			os="1.1" # 31.334
		;;
		"0cace16871ccf7c230e9a9286f34212b3c177a4672680ef9e0e736e47eec5916")
			os="1.2" # 33.56
		;;
		"6ea82dfc0c3854967947bc47b219013974b12d2407c43d5219123d87cdc1862a")
			os="1.2" # 33.43 A1000
		;;
		"bd08525ab9b3534e47766e297827d9d7808709b64616f122f3a1d0ee6c174ccc")
			os="1.2" # 33.56, ?
		;;
		"6b95e467c1895661f3e4e6c175b20c1946d111c90156978dee070654172d2d45")
			os="1.3" #
		;;
		"33bf7beed0f3da96de214ec3e1c07ed7cf9672ff87fac416a0e7a5146ae331a4")
			os="1.3" # ?
		;;
		"af29c17c4214aff6a0d86b83bb4052fb2ce230944066069c67be276654606c16")
			os="1.3.2" # 34.28
		;;
		"844df9bb92c2c585f012f20d774c907a08c025296eebc3d828b77b86355dbbb7")
			os="1.3.3" # 34.34
		;;
		"81f7175091a663e083ed75c7bd9f751b2f6a7a283aa61b76e16b9179666c3743")
			os="1.4" # 36.1, 1.4a15, alpha
		;;
		"cd23966ea82f5eddc3c9bc32c7d43c3e5b4039c842738e523f033d5db011b228")
			os="1.4" # beta ?
		;;
		"f2ed7a7d12e74d3fc073785385a2397760fc4d9c01aa8b361fc719f0bcbdcde3")
			os="2.0" # 36.68
		;;
		"f4c026a7c5abfb9dedf0e2ab7a647c250046a08aec7f145bbaa5dd301f457e43")
			os="2.0"
		;;
		"b01cc118734a13db69707014eec485ffabc1788ac64577abe4bc9051c72a3f0a")
			os="2.0" # 36.102
		;;
		"5345d19e1588db358874a2df92b4180ffa517ecced006a45710201c6b16495c3")
			os="2.05" # 37.71 A600HD
		;;
		"7aa6e88a38e95d7096934d8a3520b72b4a65075aadb60f2a50aadc346627dea3")
			os="2.05" # 37.71
		;;
		"6f82bbb9685f284bab05b7fce2703a55f2c3ec0c73c05aa090d7724cfa65d932")
			os="2.1" # 38.36
		;;
		"fb02919cc7af0d60fd0c71cc34804a8cdf76929d91e608ad8de6773bee05b4fb")
			os="2.1" # 38.35
		;;
		"80f42572e2d4cf56ef951c84a60f39ad530c19f95f51cc8a0a8d85911762d478")
			os="2.1" # 38.30
		;;
		"cb03ae35232cdb7a8f3f4d3c642908dee08c64aae1bc60748a548beb8d283bb6")
			os="3.0"
		;;
		"8e067779d6681b1e6763aec6a67750674a1cbc28d08f5a05349b41b04361aa7a")
			os="3.0" # 39.07, beta ?
		;;
		"b39739aab1efcda75be831b4fa2355eed2e726f427a2e55187a9dee3b44da9ee")
			os="3.1" # 40.42
		;;
		"1e7679ce0356312c41e20618db0791b11e7d304bf5880cfb770d0a45b3240069")
			os="3.1" # beta ?
		;;
		"3035aa6e34e952f8bd1e83f362dded2ed70a603ba9be9bb2cb0e68f617625467")
			os="3.1.4"
		;;
		"23501aa2cceef70ad179e4347ebb290cc3e229e65b9c0cc16b450b47244bebd3")
			os="3.2"
		;;
		"7b2f66e8bd1ea7c7e1493cb5f41a2f6ad75fdee650c3d53c167f22dbba41ea50")
			os="3.2.1"
		;;
		"6cd8b104ef75f4bef3bd938515993b1ad6a8295c29f05c7478ddbae27e1fce96")
			# 3.2.2 or 3.2.2.1
			os="3.2.2"
			sum=$(sha256sum "$1/Prefs/Env-Archive/Versions/Release")
			sum=${sum%% *}
			if [[ $sum = "c718e8b86eab55df5fd353d8090b1b2d25d83d1ed70ab89b1433a79930dd5ea1" ]]; then
				os="3.2.2.1"
			fi
		;;
		"86cd464a9b8beab7f365df3b6bf172bfe3a6db2e2e487eb60e3da015b56d603e")
			# 3.5 or 3.5.1
			os="3.5"
			sum=$(sha256sum "$1/Libs/asl.library")
			sum=${sum%% *}
			if [[ $sum = "d0b9898086728f0e6516cf652c3929602a32db58bab95df6ef37eba0363d86ba" ]]; then
				os="3.5.1"
			fi
		;;
		"f4f8d774c6a23038b517567905b92dcc877aeeae0e8cacb6683d1b4e344a248d")
			os="3.5.2"
		;;
		"d3d1cf6f1787949de55f65e6a9aeedd65ed9cdbbed5ed8639ff838a0485847ec")
			os="3.9"
		;;
		"0a0c2f112b082fabc0686009384d80d6466bbb6e08935807ed4cf3f2dd41cbe7")
			os="3.9.1" # bb 1
		;;
		"c7f280def402fffb83880d2a363ad8d986faa797deff83f1a2633473515fb947")
			os="3.9.2" # bb 2
		;;
		"1640a650cb7480344b301fbbbe14ee7d7d1bfd385d23af3ef689ec841bcf6267")
			os="3.9.4" # bb 3&4
		;;
	esac

	_echo "@[$FUNCNAME] detected Amiga OS version $os"
	echo "$os"
}

# to use within build scripts
# copy single file
# 1 source, linux path
# 2 destination, amiga path
# [3] permissions
# [4] options
function copy {
	local args=("$@"); local options=""; 
	[[ ${#args} -gt 1 && ${args[-1]} == options* ]] && { options="${args[-1]}"; unset args[-1]; }

	local source="$1"
	local destination="$2"
	local perm="$3"
	local destination_root="$pkgdir"
	local sbase
	local spath
	local dpath
	local dbase
	local tmp


	[[ ! $destination == *:* ]] && destination="SYS:$destination"

	tmp="$(realpath "$source")"  || _echo "%[$FUNCNAME] invalid file/path: $source"
	tmp="${tmp/$srcdir/}"

	sbase="$(base "$tmp")"; spath="$(path "$tmp")"
	dbase="$(base "$destination")"; dpath="$(path "$destination")"

	if [[ ! $dbase ]]; then dbase="$sbase"; fi
	if [ -n "$perm" ]; then
		perm="rwed"
	fi
	perm=$(sprotect "$dbase" "$perm" "${pkgname}")

	destination_root="$(makedir "${dpath}" "${options}")"

	if cp -f "${srcdir}${spath}${sbase}" "${destination_root}/${dbase}"; then
		# echo "$perm" > "${destination_root}/${dbase}.uaem"
		echo "copy \"${tmp/$pkgdir/}/${dbase}\" \"${destination}\" \"options sys=*${config['root']}*\"" >> "${pkgdir}apkg-install"
	else
		_echo "%[$FUNCNAME] copy error $source -> $destination"
	fi

}

# to use within build scripts
# create a directory
# 1 path relative to $pkgdir
# > return_str contains amiga valid path
function makedir {
	local args=("$@"); local options=""; 
	[[ ${#args} -gt 1 && ${args[-1]} == options* ]] && { options="${args[-1]}"; unset args[-1]; }

	local perm
	local s="$pkgdir"
	local path="$1"
	local destination_root="$pkgdir"

	[[ "$path" == $pkgdir* ]] && path="${path#"$pkgdir"/}"

	[[ "${path:0:1}" == "/" ]] && path="${path:1}"
	[[ "${path:0-1}" == "/" ]] && path="${path:0:${#path}-1}"

	[[ ! $path == *:* ]] && path="SYS:$path"

	s="$(path_resolve_amiga "$path")"
	s="$(path_existing_amiga "$s" "${config['root']}" )/"

	[[ $s == /* ]] && s="${s:1}"
	[[ $s == */ ]] && s="${s:0:0-1}"

	# echo "makedir \"$path\" \"options install\"" >> "${pkgdir}apkg-install"

	[[ $options =~ sys=\*([^*]+)\* ]] && destination_root="${BASH_REMATCH[1]}"

	s="${destination_root}${s}"

	mkdir -p "${s}"

	return_str="$s"
	echo "$return_str"
}

# patch aos startup like files
#  adds tagged blocks around inserted text
# 1 filename
# 2 mode (all, end)
# 3 needle (insert after line matching this)
# 4 tag (tag block with this)
# 5 text (text to be inserted)
function userpatch() {
	local file
	local filename
	local mode="$2"
	local needle="$3"
	local tag="$4"
	local text="$5"
	local patched="0"
	local out=""
	local p
	local b
	local tmp

	p=$(path "$1")
	b=$(base "$1")
	filename=$(find "$p" -iname "$b")
	if [[ ! $filename ]]; then
		filename="${p}${b}"
		touch "$filename"
	fi
	filename=$(realpath "$1")

	file=$(< "$filename")

	if [[ $mode == *end* ]]; then
		out=$(< "$filename")$'\n'$'\n'";BEGIN ${tag}"$'\n'"$text"$'\n'";END ${tag}"$'\n'
	else
		IFS=$'\n'
		for line in $file; do
			if [[ $line =~ $needle ]]; then
				tmp=$'\n'";BEGIN ${tag}"$'\n'"$text"$'\n'";END ${tag}"$'\n'
				if [[ $mode == *before* ]]; then
					[[ $patched -eq 0 ]] && {
						out+="$tmp"
						[[ $mode != *all* ]] && patched=1
					}
					out+="$line"$'\n'
				else
					out+="$line"$'\n'
					[[ $patched -eq 0 ]] && {
						out+="$tmp"
						[[ $mode != *all* ]] && patched=1
					}
				fi
			else
				out+="$line"$'\n'
			fi
		done
	fi # mode==end
	unset IFS

	cp "$filename" "${config['root']}apkg/backup/${backup}/${filename##*/}"
	echo "filecopy \"${config['root']}apkg/backup/${backup}/${filename##*/}\" \"$1\"" >> "${config['root']}apkg/$backup.rollback"
	echo "$out" > "$filename"
}

# 1 path to file
function file_type {
	local file_output
	local r="none"
	local tmp
	local size

	file_output_full="$(file "$1")"
	file_output="${file_output_full#* }"

	case "$file_output" in
		LHa) r="archive.lha" ;;
		LZX) r="archive.lzx" ;;
		Zip) r="archive.zip" ;;
		RAR) r="archive.rar" ;;
		7-zip) r="archive.7z" ;;
		"AmigaDOS script") r="script" ;;
		"AmigaGuide file") r="guide" ;;
		"AmigaOS bitmap font") r="font.bitmap" ;;
		"AmigaOS loadseg()ble executable/binary") 
			r="executable"
			[[ $1 == *.library ]] && r="library"
			[[ $1 == *.device ]] && r="device"
			[[ $1 == *.datatype ]] && r="datatype"
		;;
		"AmigaOS object/library data") r="o" ;;
		"AmigaOS outline font") r="font.outline" ;;
		"AmigaOS outline tag") r="font.tag" ;;
		"AmigaOS shared library") r="lib" ;;
		"Amiga Workbench disk icon") r="info.disk" ;;
		"Amiga Workbench drawer icon") r="info.drawer" ;;
		"Amiga Workbench garbage icon") r="info.garbage" ;;
		"Amiga Workbench project icon") r="info.project" ;;
		"Amiga Workbench tool icon") r="info.tool" ;;
		PNG*) 
			r="image.png"
			tmp="$(grep -obaUP "\x69\x63\x4f\x6e" "$1" )" # icOn
			tmp="${tmp%:*}"
			[[ "$tmp" ]] && {
				r="info"
				size="$(stat -c %s "$1")"
				tmp="$( dd if="$1" bs=1 skip=$(( tmp + 4 )) count=$(( size - tmp - 20 )) status=none | od -An -t x1 )"
				tmp="${tmp// /}"
				if [[ $tmp =~ 8000100f(........) ]]; then
					case "${BASH_REMATCH[0]}" in
						"8000100f00000001") r+=".disk" ;;
						"8000100f00000002") r+=".drawer" ;;
						"8000100f00000003") r+=".tool" ;;
						"8000100f00000004") r+=".project" ;;
						"8000100f00000005") r+=".garbage" ;;
					esac
				fi
			}
		;;
		*)
			case $file_output_full in
				*tar*) r="archive.tar" ;;
			esac
		;;
	esac
	echo "$r"
}

# 1 name assign name
# 2 path assign value to add
function add_assign {
	local name="$1"
	local path="$2"

	[[ ${name:0-1} != ':' ]] && name="${name}:"
	[[ $path != *:* ]] && path="SYS:${path}"
	[[ $path == */ ]] && path="${path:0:0-1}"

	if [[ ${assigns["$name"]} ]]; then
		assigns["${name^^}"]+=" $path"
	else
		assigns["${name^^}"]="$path"
	fi
}

# 1 path to startup file relative to ${config['root']}
function read_assigns {
	local text
	local lines
	local line
	local -a array=()
	local name
	local tmp

	readarray -t lines < "${config['root']}$1" || return 1
	for line in "${lines[@]}"; do
		[[ $line == *\;* ]] && continue
		[[ ${line^^} =~ [^\ ]*ASSIGN.* ]] || continue
		[[ ${line^^} == *EXISTS* ]] && continue	

		array=()
		tmp="$line"
		while [[ $tmp =~ ([[:graph:]]+) ]]; do
			token="${BASH_REMATCH[1]}"
			[[ ${token^^} != ADD && ${token^^} != DEFER ]] && {
				array+=("$token")
			}
			tmp="${tmp/$token}"
		done

		[[ ${array[0]^^} != ASSIGN ]] && continue

		name="${array[1]}"

		for i in "${array[@]:2}"; do
			add_assign "$name" "$i"
		done

	done

}

# 1 amiga path
# r full path
declare -A _cache_path_resolve_amiga
function path_resolve_amiga {
	local path="$1"
	local save_sys

	if [[ $path =~ [^:]+\:.* ]]; then
		:
	else
		path="SYS:$path"
	fi

	save_sys="${assigns['SYS:']}"; assigns['SYS:']=""
	while [[ $path =~ ([^:]*:)(.*) ]]; do
		assign="${BASH_REMATCH[1]^^}"
		value="${assigns[$assign]}"
		value=${value%% *}
		path="${value}/${BASH_REMATCH[2]}"
	done
	assigns['SYS:']="$save_sys"

	return_str="$path"
	echo "$return_str"
}

# 1 path full amiga directory path
# 2 path reference path directory names are matched against
function path_existing_amiga {
	local path="$1"
	local path_reference="$2"
	local -a component_array
	local component
	local existing_component
	local p

	[[ ${path:0-1} != '/' ]] && path="$path/"

	[[ ${path_reference:0-1} == '/' ]] && path_reference="${path_reference:0:0-1}"

	p="${path}"
	while [[ ${#p} -gt 0 ]]; do
		component="${p%%/*}"
		component_array+=("${component}")
		p="${p#*/}"
	done

	p=""
	for component in "${component_array[@]}"; do
		[[ ${#component} -gt 0 ]] && {
			existing_component="$(find "$path_reference$p" -maxdepth 1 -type d -iname "$component" 2>/dev/null)"
			existing_component="${existing_component##*/}"
			if [[ $existing_component ]]; then 
				p="${p}/${existing_component}"; 
			else 
				p="${p}/${component}"; 
			fi
		}
	done

	p="${p/$path_reference}"

	return_str="$p"
	echo "$p"
} 

#############################
# main fuctionality

# 1 query
# r 
# ([repo|path])@packagename(,field[=!<>])+(/field)
# ([repo|path]):packagefile(,field[=!<>])+(/field)
#
declare -A _query_cache=()
function _query {
	local query="$1"
	local type="@"
	local repo
	local fields
	local field="version"
	local dbpath
	local package
	local tmp
	local nl=$'\n'

	[[ $query != *@* && $query != *:* ]] && query="local@${query}"

	if [[ $query =~ ([^@:]+)[@:] ]]; then 
		repo="${BASH_REMATCH[1]}"; 
	else 
		_echo "%[$FUNCNAME] invalid repository/path in $query";
	fi

	[[ $query =~ [^@:]*([@:]) ]] && type="${BASH_REMATCH[1]}"

	if [[ $query =~ ,([^/]+) ]]; then 
		fields="${BASH_REMATCH[1]}"
	else
		fields=",version>0"
	fi

	if [[ $query =~ [@:][^/]+/([^/]+)$ ]]; then
		field="${BASH_REMATCH[1]}"
	else
		field="version"
	fi

	if [[ $query =~ [@:]([^,/]+) ]]; then
		package="${BASH_REMATCH[1]}"
	else
		_echo "%[$FUNCNAME] invalid package name in $query"
	fi

	if [[ ${repositories["$repo"]} ]]; then
		dbpath="${repositories["$repo"]}"
	else
		if [[ -d "$repo" ]]; then 
			dbpath="${repo}"
		else 
			_echo "%[$FUNCNAME] invalid repository in $query";
		fi
	fi
	dbpath="$(realpath "$dbpath")"
	[[ $dbpath != */ ]] && dbpath="${dbpath}/"
	[[ $fields == ,* ]] && fields="${fields:1}"

	case $type in
		"@")
			fields="${fields/,/, }"
			_repo_get_db "${repo}"
			tmp="$(sqlite3 "${APKG}tmp/$repo-repo.db" "select $field from packages where name = '$package' and $fields order by $field desc limit 1")"
		;;
		":")
			tmp="$(_extract "$dbpath$package" "apkg-metadata")"
			tmp="$(<"$tmp")"
			[[ $tmp =~ $field[[:space:]]+([^$nl]*)$nl? ]] && tmp="${BASH_REMATCH[1]}"
		;;
		"*") _echo "%[$FUNCNAME] invalid query: $query" ;;
	esac

	_echo "@[$FUNCNAME] $repo, $type, '$package', '$fields', $field = '$tmp'"
	echo "$tmp"

}

# 1 package file
function _package_info() {
	local field
	local query="$1"
	local tmp

	for field in name version cpu tags url require built packager buildscript; do
		tmp="$(_query "$query/$field")"
		echo "${field}: ${tmp}"
	done

}

# query package file in a repo
# 1 query
declare -A _meta_cache=()
function _meta {
	local query="$1"
	local filename
	local field
	local key
	local tmp
	local nl=$'\n'

	[[ ! $query =~ [^@]+@.* ]] && query="local@${query}"
	[[ $query =~ ,([^,]+) ]] && field="${BASH_REMATCH[1]}"

	if [[ -z ${_meta_cache["${query%%,*}"]} ]]; then

		filename="$(_repo_get_pkgfile "$query")"
		filename="$(_extract "$filename" "apkg-metadata")"
		tmp="$(<"$filename")"
		_meta_cache["${query%%,*}"]="$tmp"

		for key in buildscript built cpu name packager require tags url version ; do
			[[ $tmp =~ $key[[:space:]]+([^$nl]+)$nl? ]]
			_meta_cache["${query%%,*},$key"]="${BASH_REMATCH[1]}"
		done

	fi

	return_str="${_meta_cache["$query"]}"
	echo "$return_str"
}

# return package file metadata
# 1 query ( package,field )
_package_meta_last=""
_package_meta_cache=""
function package_meta {
	local meta="null"
	if [[ $_package_meta_last != $1 ]]; then
		meta="$(7z e -so "$1" apkg-metadata 2> /dev/null)"
		_package_meta_last="$1"
		_package_meta_cache="$meta"
		echo "$meta"
	else
		echo "$_package_meta_cache"
	fi
}

## extract value by key
# 1 meta
# 2 field
function meta_get() {
	:
}

# 
# 1 repo name or path
function _repo_path {
	local r="$1"

	[[ $r =~ ([^@:]+) ]] && r="${BASH_REMATCH[1]}"
	[[ ${repositories["$r"]} ]] && r="${repositories["$r"]}"

	if [[ ! -d "$r" ]]; then
		_echo "%[$FUNCNAME] invalid path: '$r'"
	fi

	r="$(realpath "$r")/"

	echo "$r"
}

# 1 name repo name or query
function _repo_get_db {
	local repo="$1"

	[[ $repo =~ ([^@]+)+@.* ]] && repo="${BASH_REMATCH[1]}"

	local url="${repositories["$repo"]}"

	[[ $url != */ ]] && { 
		url="${url}/"; 
		repositories["$repo"]="$url"; 
	}

	[[ -f "${APKG}tmp/${repo}-repo.db" ]] || {
		_get "${url}repo.db" "${APKG}tmp/${repo}-repo.db"
	}
}

# 1 query (repo@name([=<>!]version)
# n options  string (quiet)
function _repo_get_pkgfile {
	local args=("$@"); local options=""; 
	[[ ${#args} -gt 1 && ${args[-1]} == options* ]] && { options="${args[-1]}"; unset args[-1]; }

	local query="$1"
	local repo="local"
	local package=""

	if [[ $query =~ ([^@]+)@([^,]+) ]]; then
		repo="${BASH_REMATCH[1]}"
		package="${BASH_REMATCH[2]}"
	else
		_echo "%[$FUNCNAME] requires both repo name and package name ($query)"
	fi

	_repo_get_db "$repo"

	return_str="$(_query "${repo}@${package}/file")"

	_get "${repositories["$repo"]}/${return_str}" "${APKG}cache/${return_str}"

	[[ "${options}" != *quiet* ]] && echo "${APKG}cache/${return_str}"
}

# init local repository
# 1 repo|path
function _repo_init() {
	local repopath="$1"

	repopath="$(_repo_path "$repopath")"

	mkdir -p "$repopath" &> /dev/null

	rm "${repopath}repo.db" &> /dev/null

	if sqlite3 "${repopath}repo.db" "$_sql_create_table" ; then
		_echo "@[$FUNCNAME] created repository in $1"
	else
		_echo "![$FUNCNAME] failed to initialise repository in '$1'"
		return 1
	fi

}

# add package to local repository
# 1 (repo|path) target repository
# 1 (repo|path):packagefile
function repo_add_package() {
	local file="$2"
	local repo="$1"
	local name 
	local version
	local cpu
	local built
	local packager
	local url
	local query
	local repopath
	local tmp
	local p
	local b

	p="$(path "$file")"
	b="$(base "$file")"

	repopath="$(_repo_path "$repo")"

	# [[ ! -f "${repopath}repo.db" ]] && _repo_init "${repopath}"

	name=$(_query "${p}:${b}/name")
	version=$(_query "${p}:${b}/version")
	cpu=$(_query "${p}:${b}/cpu")
	built=$(_query "${p}:${b}/built")
	packager=$(_query "${p}:${b}/packager")
	url=$(_query "${p}:${b}/url")
	tags=$(_query "${p}:${b}/tags")

	query="insert into packages ('file', 'name', 'version', 'cpu', 'tags', 'built', 'packager', 'url') values ('${file##*/}', '$name', '$version', '$cpu', '$tags', '$built', '$packager', '$url' ) "
	tmp=$(sqlite3 "${repopath}repo.db" "select name from packages where name='$name' and version ='$version'")
	if [[ "$tmp" < "0" ]]; then
		sqlite3 "${repopath}repo.db" "$query"
		cp --update "$file" "$repopath" &> /dev/null
		_echo "[$FUNCNAME] added $name, $version into $repopath"
	else
		cp --update "$file" "$repopath" &> /dev/null
		_echo "[$FUNCNAME] $name $version already present in $repopath"
	fi

}

# populate repository database
# 1 repo
function repo_populate() {
	local repo="$1"
	local i
	local repopath

	repopath="$(_repo_path "$1")"

	_repo_init "$repo"

	for i in "${repopath}"/*.7z; do
		repo_add_package "$repo" "$i"
	done
}


# make sure database file is up to date
# 1 repo path
function repo_update() {
	local f
	local path="$1"

	[[ $path == */ ]] || path="${path}/"

	f=$(ls -t "${path}")

	if [[ $f =~ ^repo\.db ]]; then
		_echo "@[$FUNCNAME] database file up to date"
	else
		rm "${path}repo.db" 2&> /dev/null
		_echo "@[$FUNCNAME] removed database file in ${path}"
		repo_populate "${path}"
	fi
	
}

#
# 1 repo repo name
function repo_list {
	local repo="$1"

	_repo_get_db "$repo"

	_echo "package listing for ${repo} (${repositories[$repo]})"

	sqlite3 "${APKG}tmp/$repo-repo.db" << SQL 
.mode columns 
select name, version, cpu, built, tags from packages order by name asc
SQL

	_echo "@end of listing"
}

#
# make a "binary" package
# $1 package script name
_pkgfile=""
function _pkg_build() {
	local _script_file
	local _downloaded_file
	local _basename_file
	local _file_checksum
	local dlpaths
	typeset -A sums=()
	local shasum
	local items=0
	
	# is the script file available 
	_script_file="$1"
	[[ -z $_script_file ]] && _echo "%[$FUNCNAME] build script not found \"$_filename\"";
	_script_file=$(realpath "$_script_file")

	source "$_script_file"
	
	_echo "#[$FUNCNAME] building $name, version $version, $packager"

	# download files
	for s in "${source[@]}"; do
		items=$items+1

		IFS='*' read -r -a array <<< "$s";

		case ${#array[*]} in
			2)
				_source_file="${array[0]}"
				_file_checksum="${array[1]}"
				_basename_file="${_source_file##*/}"
				sums+=(["$_basename_file"]="$_file_checksum")
			;;
			3)
				_source_file="${array[0]}"
				_file_checksum="${array[1]}"
				_basename_file="${array[2]}"
				sums+=(["$_basename_file"]="$_file_checksum")
			;;
			*)
				_echo "![$FUNCNAME] malformed source line $s"
				exit 1
			;;
		esac
		unset IFS
		
		_downloaded_file="null"
		if [[ -f "./$_basename_file" ]]; then
			_downloaded_file="./$_basename_file"
		fi
		if [[ -f "${config['APKG']}downloads/$_basename_file" ]]; then
			_downloaded_file="./$_basename_file"
		fi

		if [[ "$_downloaded_file" == "null" ]]; then			
			_echo "[$FUNCNAME] downloading $_source_file"
			wget -q --show-progress -nc -P "${config['APKG']}downloads" -O "$_basename_file" "$_source_file" #&> /dev/null
			cp "$_basename_file" "${config['APKG']}downloads" &> /dev/null
		else
			_echo "[$FUNCNAME] $_basename_file found in download cache"
			cp "$_downloaded_file" "${config['APKG']}downloads" &> /dev/null
		fi
			
	done
	
	# verify checksums
	for f in "${!sums[@]}"; do
		shasum=$(sha256sum "${config['APKG']}downloads/$f")
		shasum=${shasum%% *}
		if [[ $shasum != "${sums[$f]}" ]]; then
			_echo "![$FUNCNAME] invalid checksum: $f= $shasum"; 
			exit 1
		else
			_echo "@[$FUNCNAME] $f chcecksum ok"
		fi
		
	done

	local pkgname="$name~$version~$cpu"
	
	rm -r "${config['APKG']}tmp/" &> /dev/null 
	mkdir -p "${config['APKG']}tmp"

	for _file in "${!sums[@]}"; do
		_unpack "${config['APKG']}downloads/$_file" "${config['APKG']}tmp"
	done

	rm -r "${config['APKG']}cache/$pkgname/" &> /dev/null 
	mkdir -p "${config['APKG']}cache/$pkgname"

	pkgdir="${config['APKG']}cache/$pkgname/"
	srcdir="${config['APKG']}tmp/"
	local _cwd="$(pwd)"

	touch "${pkgdir}apkg-install"

	_echo "@[$FUNCNAME] running build script"
	cd "$srcdir" || _echo "%invalid source directory '$srcdir')'"
	root="${config['root']}"
	build || _echo "%[$FUNCNAME] build script failed"
	unset IFS
	
	cd "$pkgdir" || _echo "%[$FUNCNAME] invalid package directory '$pkgdir'";

	_echo "[$FUNCNAME] generating install script"

	tmp="$(sort -r "${pkgdir}apkg-install" | uniq )"
	echo "$tmp" > "${pkgdir}apkg-install"

	# metadata file
	_echo "[$FUNCNAME] generating metadata"
	cd "$pkgdir" || exit 1
	touch apkg-metadata
	echo -e "#apkg $_apkg_version
name $name
version $version
cpu $cpu
tags $tags
built $(date +%s)
packager $packager
url $upstream
buildscript ${_script_file##*/}
require $require" > apkg-metadata

	cp "$_script_file" "."

	# archive all the files
	_echo "[$FUNCNAME] compressing the package"
	7z a -mx=9 "$pkgname.7z" ./* &> /dev/null
	
	cd "$_cwd" || exit 1

	_pkgfile="$(realpath "$pkgname.7z")"
	mv "${pkgdir}${pkgname}.7z" "."
	
	return_str="$_pkgfile"
}

# initializes apkg databases in ${config['root']}
function _install_init_root {
	if [ ! -d "${config['root']}/apkg/" ]; then
		_echo "@[$FUNCNAME] creating directory '${config['root']}/apkg/'"
		mkdir -p "${config['root']}/apkg"
		protect "${config['root']}/apkg" "rwed" "apkg:$_apkg_version"
		_echo "@[$FUNCNAME] created apkg directory in ${config['root']}"
	fi
	if [ ! -f "${config['root']}/apkg/apkg.db" ]; then
		_echo "@[$FUNCNAME] creating database '${config['root']}/apkg/'"
		sqlite3 "${config['root']}/apkg/apkg.db" "CREATE TABLE 'packages' ( 'file' TEXT NOT NULL, 'name' TEXT NOT NULL, 'version' TEXT NOT NULL, 'cpu' TEXT NOT NULL, 'built' TEXT NOT NULL, 'packager' TEXT NOT NULL, 'url' TEXT NOT NULL);"
		protect "${config['root']}/apkg/apkg.db" "rwed" "apkg:$_apkg_version"
		_echo "@[$FUNCNAME] created apkg database file in ${config['root']}"
	fi
}

# 1 package filename
function package_is_installed() {
	local meta
	local pkgname
	local count

	meta=$(package_meta "$1")
	pkgname=$(meta_get "$meta" "name")

	count=$(sqlite3 "${config['root']}/apkg/installed.db" "select version from packages where name='$pkgname' order by version desc")

	echo "$count"
}

# return version number for package if installed, otherwise return 0
# 1 package name
function is_installed() {
	local pkgname
	local version

	pkgname="$1"

	version=$(sqlite3 "${config['root']}apkg/installed.db" "select version from packages where name='$pkgname' order by version desc limit 1")

	if [ $version ]; then
		echo "$version"
	else
		echo "0"
	fi
}

# 1 package file name
function install_register_package() {
	local meta
	local pkgfile="$1"
	local pkgname
	local pkgversion
	local pkgcpu

	pkgfilename="$1"
	pkgname="$(_query "$(path "$pkgfile"):$(base "$pkgfile")/name")"
	pkgversion="$(_query "$(path "$pkgfile"):$(base "$pkgfile")/version")"
	pkgcpu="$(_query "$(path "$pkgfile"):$(base "$pkgfile")/cpu")"

	if [ ! -f "${config['root']}apkg/installed.db" ]; then
		sqlite3 "${config['root']}apkg/installed.db" "create table 'packages' ('file' TEXT NOT NULL, 'name' TEXT NOT NULL, 'version' TEXT NOT NULL, 'cpu' TEXT NOT NULL)" 
	fi

	sqlite3 "${config['root']}apkg/installed.db" "insert or ignore into 'packages' ('file', 'name', 'version', 'cpu') values ('$pkgfilename', '$pkgname', '$pkgversion', '$pkgcpu')"
	_echo "@[$FUNCNAME] registered package $pkgname version $pkgversion"
}

#
# 1 source
# 2 destination
# 3 backup path
function install_file {
	local source="$1"
	local destination="$2"
	local backup="$3"
	
	local psource=$(path "$source")
	local bsource=$(base "$source")
	local pdestination=$(path "$destination")
	local bdestination=$(base "$destination")

	if [[ -f "$destination" ]]; then
		_echo "@$destination backed up in $backup"
		cp "$destination" "$backup"
		rm "$destination"
		cp "$source" "$destination"
	else
		cp "$source" "$destination"
	fi

	if [[ -f "$source.uaem" ]]; then
		cp "$source.uaem" "$destination.uaem"
	fi

}

# 1 require list
# return 0 if all met, 1 otherwise
function package_check_deps() {
	local req="$1"
	local pkgname
	local pkgversion
	local relation
	local iversion
	local ret=0

	req=${req//\ /}
	if [[ $1 = "" ]]; then _echo "@no dependencies"; return 0; fi

	_echo "@[$FUNCNAME] package dependency list = '${req//,/, }'"

	IFS=,
	for r in $req; do
		relation="any"

		if [[ $r =~ ([^<>=]+)([<>=]+)([^<>=]+) ]]; then
			pkgname="${BASH_REMATCH[1]}"
			pkgversion="${BASH_REMATCH[3]}"
			relation="${BASH_REMATCH[2]}"
		else
			pkgname="$r"
			pkgversion=0
			relation="any"
		fi

		iversion=$(is_installed "$pkgname")

		if [[ $iversion > "0" ]]; then
			case $relation in
				"any")
					_echo "@[$FUNCNAME] $pkgname required, $iversion installed"
				;;
				">")
					if [[ $iversion > $pkgversion ]]; then
						_echo "@[$FUNCNAME] $pkgname > $pkgversion required, $iversion installed"
					fi
				;;
				"<")
					if [[ $iversion < $pkgversion ]]; then
						_echo "@[$FUNCNAME] $pkgname > $pkgversion required, $iversion installed"
					fi
				;;				
				"=")
					if [[ $iversion == $pkgversion ]]; then
						_echo "@[$FUNCNAME] $pkgname > $pkgversion required, $iversion installed"
					fi
				;;
			esac
		else
			_echo "%[$FUNCNAME] $pkgname version $pkgversion required, none installed"
		fi
	
	done
	unset IFS

	return $ret
}

#
# install the package
# 1 package file
function install_package() {
	local filename
	local files
	local fbase
	local osversion
	local tmpdir=""
	local tmpdir_length=0
	local meta
	local backup
	local pkgname
	local pkgversion
	root="${config['root']}" # needed within build scripts

	_install_init_root

	filename=$(realpath "$1")

	if [ ! -f "$filename" ]; then _echo "%[$FUNCNAME] file not found $filename"; fi

	osversion=$(_detectos "${config['root']}")

	pkgname=$(_query "$(path "$filename"):$(base "$filename")/name")
	pkgversion=$(_query "$(path "$filename"):$(base "$filename")/version")
	backup="$pkgname-$pkgversion"

	[[ -f "${config['root']}/apkg/$backup.rollback" ]] && _echo "%$pkgname $pkgversion already installed"

	_echo "#installing $_filename"
	
	tmpdir="${config['APKG']}tmp/"
	rm -r "$tmpdir" #&> /dev/null
	mkdir -p "$tmpdir"
	tmpdir_length=${#tmpdir}

	_unpack "$filename" "${config['APKG']}tmp"

	tmp2=$(_query "$(path "$filename"):$(base "$filename")/buildscript")

	source "${config['APKG']}tmp/$tmp2"

	package_check_deps "$require"

	if [[ $? -gt 0 ]]; then _echo "!dependencies not met"; exit 1; fi

	_echo "installing files"
	mkdir -p "${config['root']}/apkg/backup/$backup"
	true > "${config['root']}/apkg/$pkgname-$pkgversion.rollback"

	IFS=$'\n'
	files=$(find "${config['APKG']}tmp" ! -iname "*.uaem" ! -iname "apkg-*" ! -iname "*.apkg")
	for f in $files; do
		fbase=$(base "$f")
		if [[ "$f/" == "$tmpdir" ]]; then continue; fi
		if [ -d "$f" ]; then
			[[ ! -d "${config['root']}/${f:$tmpdir_length}" ]] && {
				mkdir -p "${config['root']}/${f:$tmpdir_length}"
				protect "${config['root']}/${f:$tmpdir_length}"
				echo -e "dirdelete ${f:$tmpdir_length}" >> "${config['root']}/apkg/$pkgname-$pkgversion.rollback"
			}
		fi
		if [ -f "$f" ]; then
			if [ -f "${config['root']}/${f:$tmpdir_length}" ]; then
				# conflicting file
				install_file "$f" "${config['root']}${f:$tmpdir_length}" "${config['root']}apkg/backup/$backup"

				echo "filedelete ${f:$tmpdir_length}" >> "${config['root']}apkg/$pkgname-$pkgversion.rollback"
				echo "filecopy ${config['root']}apkg/backup/$backup/$fbase ${config['root']}${f:$tmpdir_length}" >> "${config['root']}apkg/$pkgname-$pkgversion.rollback"
			else
				install_file "$f" "${config['root']}${f:$tmpdir_length}" "${config['root']}apkg/backup/$backup"

				echo "filedelete ${f:$tmpdir_length}" >> "${config['root']}apkg/$pkgname-$pkgversion.rollback"
			fi
		fi

	done
	unset IFS

	if [[ $(type -t post_install) == "function" ]]; then
		_echo "running post install script"
		post_install || exit 1
	else
		_echo "@no post_install script"
	fi

	sort -r "${config['root']}/apkg/$pkgname-$pkgversion.rollback" > "${config['root']}/apkg/$pkgname-$pkgversion.rollback.tmp"
	rm "${config['root']}/apkg/$pkgname-$pkgversion.rollback"
	mv "${config['root']}/apkg/$pkgname-$pkgversion.rollback.tmp" "${config['root']}/apkg/$pkgname-$pkgversion.rollback"

	install_register_package "$1"

	_echo "installation complete"
}

# install single package from a repository
# 1 package package query ( repo@name([=<>!]version) )
function install_repo() {
	local query="$1"
	local pkgname
	local pkgversion
	local pkgfile

	pkgfile="$(_repo_get_pkgfile "$query")"

	[[ "$pkgfile" ]] || _echo "%package ${1} not found in ${repo}"
	
	install_package "${pkgfile}"
}

#############################

[[ -z "$APKG" ]] && APKG="$HOME/.apkg"
[[ "$APKG" != */ ]] && APKG="$APKG/"
[[ ! -d "$APKG" ]] && {
	_echo "@creating working directory, path: '$APKG'"
	mkdir -p "$APKG"
	}
[[ ! -d "${APKG}repo" ]] && mkdir "${APKG}repo"
[[ ! -d "${APKG}tmp" ]] && mkdir "${APKG}tmp"
[[ ! -d "${APKG}downloads" ]] && mkdir "${APKG}downloads"
[[ ! -d "${APKG}cache" ]] && mkdir "${APKG}cache"
[[ ! -d "${APKG}RAM" ]] && { 
	mkdir "${APKG}RAM"; 
	mkdir "${APKG}RAM/T"; 
	mkdir "${APKG}RAM/CLIPBOARDS"; 
	mkdir "${APKG}RAM/ENV"
	}

rm -rd "${APKG}cache/"* &> /dev/null
rm -rd "${APKG}tmp/"* &> /dev/null

declare -A assigns

_read_config "$HOME/.apkg/apkg.config" 
_read_config "./apkg.config"

for key in "${!config[@]}"; do _echo "@$key = ${config[$key]}"; done
for key in "${!repositories[@]}"; do _echo "@repo $key = ${repositories[$key]}"; done

[[ ! -d "${config['root']}" ]] && _echo "%invalid target root path: ${config['root']}"
[[ ! -d "${repositories['local']}" ]] && _echo "%invalid local repo path: '${repositories['local']}'"

if [[ -z ${config['cpu']} ]]; then config['cpu']="68020"; fi

config['APKG']="$APKG"

assigns['SYS:']="$(realpath "${config['root']}")"
assigns['RAM:']="${APKG}RAM"
add_assign "C:" "SYS:C"
add_assign "DEVS:" "SYS:Devs"
add_assign "ENVARC:" "Prefs/Env-Archive"
add_assign "FONTS:" "SYS:Fonts"
add_assign "L:" "SYS:L"
add_assign "LIBS:" "SYS:Libs"
add_assign "S:" "SYS:S"
read_assigns "S/Startup-Sequence" &> /dev/null
read_assigns "S/User-Startup" &> /dev/null

#
# print config
for key in "${!v[@]}"; do _echo "@$key = ${v[$key]}"; done
for key in "${!assigns[@]}"; do _echo "@assign $key ${assigns[$key]}"; done

########
# top level logic

case $_mode in
	"build")
		[[ ${#_input_names} -eq 0 ]] && _echo "%no input files"
		for _filename in "${_input_names[@]}"; do
			_pkg_build "$_filename"
			_echo "[$FUNCNAME] created package: $return_str"
		done
	;;
	"make")
		[[ ${#_input_names} -eq 0 ]] && _echo "%no input files"
		for _filename in "${_input_names[@]}"; do
			_pkg_build "$_filename"
			repo_add_package "local" "$return_str"
			rm "$return_str"
		done
	;;	
	"query")
		[[ ${#_input_names} -eq 0 ]] && _echo "%no queries"
		for _filename in "${_input_names[@]}"; do
			tmp="$(_query "$_filename")"
			if [[ $tmp == "0" ]]; then
				echo "no result for $_filename"
			else
				echo "$_filename : '$tmp'"
			fi
		done
	;;		
	"install")
		tmp=0
		[[ ${#_input_names} -eq 0 ]] && _echo "%no input files"
		for _filename in "${_input_names[@]}"; do
			if [[ -f $_filename && $_filename != *.apkg ]]; then
				install_package "$_filename"
				tmp=1
			fi
			if [[ $_filename == *.apkg ]]; then
				_pkg_build "$_filename"
				install_package "${repo}${_pkgfile}"
				tmp=1
			fi
			if [ $tmp -gt 0 ]; then
				: # done
			else
				[[ $_filename != *@* ]] && _filename="local@${_filename}"
				install_repo "$_filename"
			fi
		done
	;;
	"repo-init")
		_repo_init "${repositories['local']}"
		repo_populate "${repositories['local']}"
	;;
	"repo-list")
		repo_list "local"
	;;
	"repo-rescan")
		repo_populate "${repositories['local']}"
	;;
	"package-info")
		for _filename in "${_input_names[@]}"; do _package_info "$_filename"; done
	;;
	"version")
		echo $_apkg_version
	;;
esac


